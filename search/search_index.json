{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Babylon_ros is a Node.JS API for rendering ROS 2 based URDFs and Xacro in a web browser or Visual Studio Code compatible extension using the Babylon.js graphics engine . \ud83c\udfaf Interactive 3D robot viewer embedded above \ud83d\udd04 Rotate with mouse \u2022 \ud83d\udcf8 Download screenshots \u2022 \ud83d\udd17 Toggle wireframe","title":"Home"},{"location":"api-overview.html","text":"Babylon ROS API Overview The Babylon ROS library provides a comprehensive TypeScript/JavaScript API for loading, visualizing, and interacting with URDF (Unified Robot Description Format) files in web browsers using Babylon.js. Core Architecture The library is built around several key classes that work together to provide a complete robot visualization system: RobotScene - Main scene management and interaction controller Robot - Robot model representation and management Link - Individual robot link components Joint - Robot joint definitions and behaviors Visual - Visual geometry representations Material - Material definitions and textures Geometry System The library supports various geometry types for robot components: IGeometry Interface - Base geometry interface Mesh - Complex mesh geometries from files Box - Box primitive geometries Sphere - Sphere primitive geometries Cylinder - Cylinder primitive geometries Interactive Controls Advanced interaction and manipulation tools: JointPositionGizmo - Position manipulation for joints JointRotationGizmo - Rotation manipulation for joints Utilities Helper functions and utilities: Utilities - Parsing and transformation utilities Quick Start import { RobotScene } from '@ranchhandrobotics/babylon_ros' ; // Create a new robot scene const robotScene = new RobotScene (); // Initialize the 3D scene await robotScene . createScene ( canvas ); // Create the UI robotScene . createUI (); // Load a URDF file const urdfText = await fetch ( 'path/to/robot.urdf' ). then ( r => r . text ()); await robotScene . applyURDF ( urdfText ); Features URDF Loading : Complete support for URDF specification including links, joints, materials, and meshes Interactive 3D Visualization : Real-time 3D rendering with camera controls Joint Manipulation : Interactive gizmos for moving and rotating joints Material Support : Textures, colors, and material properties Grid System : Configurable measurement grids (10cm, 1m increments) Screenshot Capture : Programmatic screenshot functionality Responsive UI : Hamburger menu system with feature toggles Browser Compatibility The library works in all modern browsers that support WebGL and ES6 modules: Chrome 80+ Firefox 75+ Safari 13+ Edge 80+ Dependencies Babylon.js : 3D rendering engine Babylon.js Materials : Extended material system Babylon.js GUI : User interface components Babylon.js Collada Loader : COLLADA/DAE file support","title":"Overview"},{"location":"api-overview.html#babylon-ros-api-overview","text":"The Babylon ROS library provides a comprehensive TypeScript/JavaScript API for loading, visualizing, and interacting with URDF (Unified Robot Description Format) files in web browsers using Babylon.js.","title":"Babylon ROS API Overview"},{"location":"api-overview.html#core-architecture","text":"The library is built around several key classes that work together to provide a complete robot visualization system: RobotScene - Main scene management and interaction controller Robot - Robot model representation and management Link - Individual robot link components Joint - Robot joint definitions and behaviors Visual - Visual geometry representations Material - Material definitions and textures","title":"Core Architecture"},{"location":"api-overview.html#geometry-system","text":"The library supports various geometry types for robot components: IGeometry Interface - Base geometry interface Mesh - Complex mesh geometries from files Box - Box primitive geometries Sphere - Sphere primitive geometries Cylinder - Cylinder primitive geometries","title":"Geometry System"},{"location":"api-overview.html#interactive-controls","text":"Advanced interaction and manipulation tools: JointPositionGizmo - Position manipulation for joints JointRotationGizmo - Rotation manipulation for joints","title":"Interactive Controls"},{"location":"api-overview.html#utilities","text":"Helper functions and utilities: Utilities - Parsing and transformation utilities","title":"Utilities"},{"location":"api-overview.html#quick-start","text":"import { RobotScene } from '@ranchhandrobotics/babylon_ros' ; // Create a new robot scene const robotScene = new RobotScene (); // Initialize the 3D scene await robotScene . createScene ( canvas ); // Create the UI robotScene . createUI (); // Load a URDF file const urdfText = await fetch ( 'path/to/robot.urdf' ). then ( r => r . text ()); await robotScene . applyURDF ( urdfText );","title":"Quick Start"},{"location":"api-overview.html#features","text":"URDF Loading : Complete support for URDF specification including links, joints, materials, and meshes Interactive 3D Visualization : Real-time 3D rendering with camera controls Joint Manipulation : Interactive gizmos for moving and rotating joints Material Support : Textures, colors, and material properties Grid System : Configurable measurement grids (10cm, 1m increments) Screenshot Capture : Programmatic screenshot functionality Responsive UI : Hamburger menu system with feature toggles","title":"Features"},{"location":"api-overview.html#browser-compatibility","text":"The library works in all modern browsers that support WebGL and ES6 modules: Chrome 80+ Firefox 75+ Safari 13+ Edge 80+","title":"Browser Compatibility"},{"location":"api-overview.html#dependencies","text":"Babylon.js : 3D rendering engine Babylon.js Materials : Extended material system Babylon.js GUI : User interface components Babylon.js Collada Loader : COLLADA/DAE file support","title":"Dependencies"},{"location":"installation.html","text":"Installation Babylon_ros is available via the Node Package Manager package that can be installed in your web application. To install, run: npm install --save @ranchhandrobotics/babylon_ros Usage To use Babylon ROS in your web application, you need to set up a basic HTML page and include the Babylon.js library along with the Babylon ROS package. Here\u2019s a simple example which renders a the Test Page included in this package: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < style nonce = \"${nonce}\" > html , body { overflow : hidden ; width : 100 % ; height : 100 % ; margin : 0 ; padding : 0 ; } # renderCanvas { width : 100 % ; height : 100 % ; touch-action : none ; } </ style > < title > URDF Preview </ title > </ head > < body > < canvas id = \"renderCanvas\" touch-action = \"none\" ></ canvas > < script src = \"../node_modules/babylonjs/babylon.js\" ></ script > < script src = \"./ros.js\" ></ script > < script > window . addEventListener ( \"load\" , babylon_ros . RenderTestMain ); </ script > </ body > </ html >","title":"Installation"},{"location":"installation.html#installation","text":"Babylon_ros is available via the Node Package Manager package that can be installed in your web application. To install, run: npm install --save @ranchhandrobotics/babylon_ros","title":"Installation"},{"location":"installation.html#usage","text":"To use Babylon ROS in your web application, you need to set up a basic HTML page and include the Babylon.js library along with the Babylon ROS package. Here\u2019s a simple example which renders a the Test Page included in this package: <!DOCTYPE html> < html lang = \"en\" > < head > < meta charset = \"UTF-8\" > < meta name = \"viewport\" content = \"width=device-width, initial-scale=1.0\" > < style nonce = \"${nonce}\" > html , body { overflow : hidden ; width : 100 % ; height : 100 % ; margin : 0 ; padding : 0 ; } # renderCanvas { width : 100 % ; height : 100 % ; touch-action : none ; } </ style > < title > URDF Preview </ title > </ head > < body > < canvas id = \"renderCanvas\" touch-action = \"none\" ></ canvas > < script src = \"../node_modules/babylonjs/babylon.js\" ></ script > < script src = \"./ros.js\" ></ script > < script > window . addEventListener ( \"load\" , babylon_ros . RenderTestMain ); </ script > </ body > </ html >","title":"Usage"},{"location":"urdf.html","text":"URDF Viewer The generic URDF viewer accepts any URDF or Xacro file via URL parameters: https://ranchhandrobotics.com/babylon_ros/urdf-viewer.html?urdf=YOUR_URDF_URL Example URLs: Mule Robot : https://ranch-hand-robotics.github.io/babylon_ros/urdf-viewer.html?urdf=https://raw.githubusercontent.com/Ranch-Hand-Robotics/babylon_ros/main/test/testdata/mule.urdf R2 Robot : https://ranch-hand-robotics.github.io/babylon_ros/urdf-viewer.html?urdf=https://raw.githubusercontent.com/Ranch-Hand-Robotics/babylon_ros/main/test/testdata/r2.urdf This makes it easy to embed live robot visualizations in any README by simply linking to the viewer with your URDF file URL.","title":"URDF Viewer"},{"location":"urdf.html#urdf-viewer","text":"The generic URDF viewer accepts any URDF or Xacro file via URL parameters: https://ranchhandrobotics.com/babylon_ros/urdf-viewer.html?urdf=YOUR_URDF_URL Example URLs: Mule Robot : https://ranch-hand-robotics.github.io/babylon_ros/urdf-viewer.html?urdf=https://raw.githubusercontent.com/Ranch-Hand-Robotics/babylon_ros/main/test/testdata/mule.urdf R2 Robot : https://ranch-hand-robotics.github.io/babylon_ros/urdf-viewer.html?urdf=https://raw.githubusercontent.com/Ranch-Hand-Robotics/babylon_ros/main/test/testdata/r2.urdf This makes it easy to embed live robot visualizations in any README by simply linking to the viewer with your URDF file URL.","title":"URDF Viewer"},{"location":"api/geometry.html","text":"Geometry API The geometry system provides 3D shapes for robot visual and collision components through the IGeometry interface and concrete implementations. IGeometry Interface The base interface that all geometry types implement: interface IGeometry { meshes : BABYLON.AbstractMesh [] | undefined ; transform : BABYLON.TransformNode | undefined ; create ( scene : BABYLON.Scene , mat : Material | undefined ) : void ; dispose () : void ; setLoadCompleteCallback ? ( callback : () => void ) : void ; } Properties meshes : Array of Babylon.js mesh objects transform : Transform node for positioning and hierarchy Methods create() : Creates the geometry in the scene with optional material dispose() : Cleans up geometry resources setLoadCompleteCallback() : Optional callback for async loading completion Primitive Geometries Box Geometry Creates rectangular box shapes. import { Box } from '@ranchhandrobotics/babylon_ros' ; const box = new Box ( width , height , depth ); Constructor Parameters: - width : number - X-axis dimension (meters) - height : number - Y-axis dimension (meters) - depth : number - Z-axis dimension (meters) Example: // Create a 2x1x0.5 meter box const chassisBox = new Box ( 2.0 , 1.0 , 0.5 ); chassisBox . create ( scene , material ); Sphere Geometry Creates spherical shapes. import { Sphere } from '@ranchhandrobotics/babylon_ros' ; const sphere = new Sphere ( radius ); Constructor Parameters: - radius : number - Sphere radius (meters) Example: // Create a 10cm radius sphere const ballJoint = new Sphere ( 0.1 ); ballJoint . create ( scene , material ); Cylinder Geometry Creates cylindrical shapes. import { Cylinder } from '@ranchhandrobotics/babylon_ros' ; const cylinder = new Cylinder ( length , radius ); Constructor Parameters: - length : number - Cylinder height/length (meters) - radius : number - Cylinder radius (meters) Special Behavior: - Automatically rotated 90\u00b0 around X-axis to align with ROS conventions - ROS cylinders are along Z-axis, Babylon.js cylinders are along Y-axis Example: // Create a 50cm long, 5cm radius cylinder const robotArm = new Cylinder ( 0.5 , 0.05 ); robotArm . create ( scene , material ); Mesh Geometry Loads complex 3D models from files. import { Mesh } from '@ranchhandrobotics/babylon_ros' ; const mesh = new Mesh ( uri , scale ); Constructor Parameters: - uri : string - Path to 3D model file - scale : BABYLON.Vector3 - Scaling factors for X, Y, Z axes Supported Formats: - COLLADA (.dae) : Full feature support including materials, animations - STL (.stl) : Basic mesh geometry (automatically handles coordinate conversion) - OBJ (.obj) : Basic mesh geometry - glTF (.gltf, .glb) : Modern format with full PBR material support Properties Property Type Description uri string File path or URL to the mesh scale BABYLON.Vector3 Scaling applied to loaded mesh meshes BABYLON.AbstractMesh[] \\| undefined Loaded mesh objects transform BABYLON.TransformNode \\| undefined Transform node material Material \\| undefined Override material skeletons BABYLON.Skeleton[] \\| undefined Animation skeletons Methods setLoadCompleteCallback(callback: () => void): void Sets a callback function to be called when mesh loading completes. Example: const robotMesh = new Mesh ( \"robot_body.dae\" , new BABYLON . Vector3 ( 1 , 1 , 1 )); robotMesh . setLoadCompleteCallback (() => { console . log ( \"Robot mesh loaded successfully\" ); // Perform post-load operations }); robotMesh . create ( scene , material ); Usage Examples Creating Primitive Shapes // Robot chassis - large box const chassis = new Box ( 2.0 , 1.0 , 0.3 ); const chassisMaterial = new Material (); chassisMaterial . color = new BABYLON . Color4 ( 0.5 , 0.5 , 0.5 , 1 ); chassis . create ( scene , chassisMaterial ); // Wheel - cylinder const wheel = new Cylinder ( 0.1 , 0.3 ); // 10cm wide, 30cm diameter const rubberMaterial = new Material (); rubberMaterial . color = new BABYLON . Color4 ( 0.1 , 0.1 , 0.1 , 1 ); wheel . create ( scene , rubberMaterial ); // Sensor housing - sphere const lidarDome = new Sphere ( 0.08 ); // 8cm radius const blackMaterial = new Material (); blackMaterial . color = new BABYLON . Color4 ( 0 , 0 , 0 , 1 ); lidarDome . create ( scene , blackMaterial ); Loading Complex Meshes // High-detail robot arm from COLLADA file const armMesh = new Mesh ( \"models/robot_arm_detailed.dae\" , new BABYLON . Vector3 ( 1 , 1 , 1 ) // No scaling ); // Handle async loading let meshLoadComplete = false ; armMesh . setLoadCompleteCallback (() => { meshLoadComplete = true ; console . log ( \"Arm mesh loaded\" ); }); armMesh . create ( scene , material ); // Scaled STL mesh (STL files often need scaling) const gearMesh = new Mesh ( \"parts/gear.stl\" , new BABYLON . Vector3 ( 0.001 , 0.001 , 0.001 ) // Scale from mm to m ); gearMesh . create ( scene , metalMaterial ); Geometry in Visual Components const visual = new Visual (); visual . name = \"robot_body\" ; // Use different geometry based on requirements if ( detailedMode ) { // High-detail mesh for close viewing visual . geometry = new Mesh ( \"detailed_body.dae\" , new BABYLON . Vector3 ( 1 , 1 , 1 )); } else { // Simple box for performance visual . geometry = new Box ( 1.5 , 0.8 , 0.4 ); } visual . create ( scene , materialMap ); Coordinate System Conversions ROS to Babylon.js Coordinate Systems The geometry classes handle coordinate system differences: ROS Conventions: - X-forward, Y-left, Z-up - Cylinders along Z-axis - STL files in millimeters Babylon.js Conventions: - X-right, Y-up, Z-forward - Cylinders along Y-axis - Meters for all units Automatic Conversions // Cylinder: Automatically rotated 90\u00b0 around X-axis const cylinder = new Cylinder ( 0.5 , 0.05 ); // Result: 50cm cylinder pointing along Z-axis (ROS convention) // STL Mesh: Automatically handles coordinate conversion const stlMesh = new Mesh ( \"part.stl\" , new BABYLON . Vector3 ( 0.001 , 0.001 , 0.001 )); // Result: Proper orientation and scaling from mm to meters Performance Considerations Primitive Geometries Fast Creation : Generated procedurally, very fast Low Memory : Minimal memory footprint Good for Collision : Perfect for simple collision shapes Mesh Geometries Loading Time : Files must be loaded from disk/network Memory Usage : Can be large for detailed models Rendering Cost : Complex meshes impact rendering performance Optimization Strategies // Use appropriate level of detail const simpleCollision = new Box ( 2 , 1 , 0.5 ); // Simple collision const detailedVisual = new Mesh ( \"detailed.dae\" , scale ); // Detailed visual // Scale optimization const lowPolyMesh = new Mesh ( \"low_poly.dae\" , scale ); // For distant objects const highPolyMesh = new Mesh ( \"high_poly.dae\" , scale ); // For close viewing // Async loading management const loader = new Mesh ( \"large_model.dae\" , scale ); loader . setLoadCompleteCallback (() => { // Enable rendering after loading robotScene . readyToRender = true ; }); Material Integration Geometry with Materials // Primitive with solid color const box = new Box ( 1 , 1 , 1 ); const redMaterial = new Material (); redMaterial . color = new BABYLON . Color4 ( 1 , 0 , 0 , 1 ); box . create ( scene , redMaterial ); // Mesh with texture (material can be embedded in file) const texturedMesh = new Mesh ( \"textured_model.dae\" , scale ); texturedMesh . create ( scene , undefined ); // Uses embedded materials // Mesh with override material const meshWithOverride = new Mesh ( \"model.dae\" , scale ); meshWithOverride . create ( scene , customMaterial ); // Overrides embedded materials Error Handling File Loading Errors const mesh = new Mesh ( \"missing_file.dae\" , scale ); mesh . setLoadCompleteCallback (() => { if ( mesh . meshes && mesh . meshes . length > 0 ) { console . log ( \"Mesh loaded successfully\" ); } else { console . error ( \"Failed to load mesh\" ); } }); Disposal and Cleanup // Always dispose geometries to prevent memory leaks geometry . dispose (); // For meshes, this cleans up: // - Loaded mesh data // - Transform nodes // - Associated materials (if not shared) // - Animation data Integration with Robot Components Geometries are typically used within Visual components: // Part of robot loading process const link = new Link (); const visual = new Visual (); // Choose appropriate geometry visual . geometry = new Box ( 1 , 0.5 , 0.3 ); // Simple box // OR visual . geometry = new Mesh ( \"complex_part.dae\" , scale ); // Complex mesh link . visuals . push ( visual ); This creates a complete chain: Robot \u2192 Link \u2192 Visual \u2192 Geometry \u2192 Babylon.js Mesh","title":"Geometry Types"},{"location":"api/geometry.html#geometry-api","text":"The geometry system provides 3D shapes for robot visual and collision components through the IGeometry interface and concrete implementations.","title":"Geometry API"},{"location":"api/geometry.html#igeometry-interface","text":"The base interface that all geometry types implement: interface IGeometry { meshes : BABYLON.AbstractMesh [] | undefined ; transform : BABYLON.TransformNode | undefined ; create ( scene : BABYLON.Scene , mat : Material | undefined ) : void ; dispose () : void ; setLoadCompleteCallback ? ( callback : () => void ) : void ; }","title":"IGeometry Interface"},{"location":"api/geometry.html#properties","text":"meshes : Array of Babylon.js mesh objects transform : Transform node for positioning and hierarchy","title":"Properties"},{"location":"api/geometry.html#methods","text":"create() : Creates the geometry in the scene with optional material dispose() : Cleans up geometry resources setLoadCompleteCallback() : Optional callback for async loading completion","title":"Methods"},{"location":"api/geometry.html#primitive-geometries","text":"","title":"Primitive Geometries"},{"location":"api/geometry.html#box-geometry","text":"Creates rectangular box shapes. import { Box } from '@ranchhandrobotics/babylon_ros' ; const box = new Box ( width , height , depth ); Constructor Parameters: - width : number - X-axis dimension (meters) - height : number - Y-axis dimension (meters) - depth : number - Z-axis dimension (meters) Example: // Create a 2x1x0.5 meter box const chassisBox = new Box ( 2.0 , 1.0 , 0.5 ); chassisBox . create ( scene , material );","title":"Box Geometry"},{"location":"api/geometry.html#sphere-geometry","text":"Creates spherical shapes. import { Sphere } from '@ranchhandrobotics/babylon_ros' ; const sphere = new Sphere ( radius ); Constructor Parameters: - radius : number - Sphere radius (meters) Example: // Create a 10cm radius sphere const ballJoint = new Sphere ( 0.1 ); ballJoint . create ( scene , material );","title":"Sphere Geometry"},{"location":"api/geometry.html#cylinder-geometry","text":"Creates cylindrical shapes. import { Cylinder } from '@ranchhandrobotics/babylon_ros' ; const cylinder = new Cylinder ( length , radius ); Constructor Parameters: - length : number - Cylinder height/length (meters) - radius : number - Cylinder radius (meters) Special Behavior: - Automatically rotated 90\u00b0 around X-axis to align with ROS conventions - ROS cylinders are along Z-axis, Babylon.js cylinders are along Y-axis Example: // Create a 50cm long, 5cm radius cylinder const robotArm = new Cylinder ( 0.5 , 0.05 ); robotArm . create ( scene , material );","title":"Cylinder Geometry"},{"location":"api/geometry.html#mesh-geometry","text":"Loads complex 3D models from files. import { Mesh } from '@ranchhandrobotics/babylon_ros' ; const mesh = new Mesh ( uri , scale ); Constructor Parameters: - uri : string - Path to 3D model file - scale : BABYLON.Vector3 - Scaling factors for X, Y, Z axes Supported Formats: - COLLADA (.dae) : Full feature support including materials, animations - STL (.stl) : Basic mesh geometry (automatically handles coordinate conversion) - OBJ (.obj) : Basic mesh geometry - glTF (.gltf, .glb) : Modern format with full PBR material support","title":"Mesh Geometry"},{"location":"api/geometry.html#properties_1","text":"Property Type Description uri string File path or URL to the mesh scale BABYLON.Vector3 Scaling applied to loaded mesh meshes BABYLON.AbstractMesh[] \\| undefined Loaded mesh objects transform BABYLON.TransformNode \\| undefined Transform node material Material \\| undefined Override material skeletons BABYLON.Skeleton[] \\| undefined Animation skeletons","title":"Properties"},{"location":"api/geometry.html#methods_1","text":"","title":"Methods"},{"location":"api/geometry.html#setloadcompletecallbackcallback-void-void","text":"Sets a callback function to be called when mesh loading completes. Example: const robotMesh = new Mesh ( \"robot_body.dae\" , new BABYLON . Vector3 ( 1 , 1 , 1 )); robotMesh . setLoadCompleteCallback (() => { console . log ( \"Robot mesh loaded successfully\" ); // Perform post-load operations }); robotMesh . create ( scene , material );","title":"setLoadCompleteCallback(callback: () =&gt; void): void"},{"location":"api/geometry.html#usage-examples","text":"","title":"Usage Examples"},{"location":"api/geometry.html#creating-primitive-shapes","text":"// Robot chassis - large box const chassis = new Box ( 2.0 , 1.0 , 0.3 ); const chassisMaterial = new Material (); chassisMaterial . color = new BABYLON . Color4 ( 0.5 , 0.5 , 0.5 , 1 ); chassis . create ( scene , chassisMaterial ); // Wheel - cylinder const wheel = new Cylinder ( 0.1 , 0.3 ); // 10cm wide, 30cm diameter const rubberMaterial = new Material (); rubberMaterial . color = new BABYLON . Color4 ( 0.1 , 0.1 , 0.1 , 1 ); wheel . create ( scene , rubberMaterial ); // Sensor housing - sphere const lidarDome = new Sphere ( 0.08 ); // 8cm radius const blackMaterial = new Material (); blackMaterial . color = new BABYLON . Color4 ( 0 , 0 , 0 , 1 ); lidarDome . create ( scene , blackMaterial );","title":"Creating Primitive Shapes"},{"location":"api/geometry.html#loading-complex-meshes","text":"// High-detail robot arm from COLLADA file const armMesh = new Mesh ( \"models/robot_arm_detailed.dae\" , new BABYLON . Vector3 ( 1 , 1 , 1 ) // No scaling ); // Handle async loading let meshLoadComplete = false ; armMesh . setLoadCompleteCallback (() => { meshLoadComplete = true ; console . log ( \"Arm mesh loaded\" ); }); armMesh . create ( scene , material ); // Scaled STL mesh (STL files often need scaling) const gearMesh = new Mesh ( \"parts/gear.stl\" , new BABYLON . Vector3 ( 0.001 , 0.001 , 0.001 ) // Scale from mm to m ); gearMesh . create ( scene , metalMaterial );","title":"Loading Complex Meshes"},{"location":"api/geometry.html#geometry-in-visual-components","text":"const visual = new Visual (); visual . name = \"robot_body\" ; // Use different geometry based on requirements if ( detailedMode ) { // High-detail mesh for close viewing visual . geometry = new Mesh ( \"detailed_body.dae\" , new BABYLON . Vector3 ( 1 , 1 , 1 )); } else { // Simple box for performance visual . geometry = new Box ( 1.5 , 0.8 , 0.4 ); } visual . create ( scene , materialMap );","title":"Geometry in Visual Components"},{"location":"api/geometry.html#coordinate-system-conversions","text":"","title":"Coordinate System Conversions"},{"location":"api/geometry.html#ros-to-babylonjs-coordinate-systems","text":"The geometry classes handle coordinate system differences: ROS Conventions: - X-forward, Y-left, Z-up - Cylinders along Z-axis - STL files in millimeters Babylon.js Conventions: - X-right, Y-up, Z-forward - Cylinders along Y-axis - Meters for all units","title":"ROS to Babylon.js Coordinate Systems"},{"location":"api/geometry.html#automatic-conversions","text":"// Cylinder: Automatically rotated 90\u00b0 around X-axis const cylinder = new Cylinder ( 0.5 , 0.05 ); // Result: 50cm cylinder pointing along Z-axis (ROS convention) // STL Mesh: Automatically handles coordinate conversion const stlMesh = new Mesh ( \"part.stl\" , new BABYLON . Vector3 ( 0.001 , 0.001 , 0.001 )); // Result: Proper orientation and scaling from mm to meters","title":"Automatic Conversions"},{"location":"api/geometry.html#performance-considerations","text":"","title":"Performance Considerations"},{"location":"api/geometry.html#primitive-geometries_1","text":"Fast Creation : Generated procedurally, very fast Low Memory : Minimal memory footprint Good for Collision : Perfect for simple collision shapes","title":"Primitive Geometries"},{"location":"api/geometry.html#mesh-geometries","text":"Loading Time : Files must be loaded from disk/network Memory Usage : Can be large for detailed models Rendering Cost : Complex meshes impact rendering performance","title":"Mesh Geometries"},{"location":"api/geometry.html#optimization-strategies","text":"// Use appropriate level of detail const simpleCollision = new Box ( 2 , 1 , 0.5 ); // Simple collision const detailedVisual = new Mesh ( \"detailed.dae\" , scale ); // Detailed visual // Scale optimization const lowPolyMesh = new Mesh ( \"low_poly.dae\" , scale ); // For distant objects const highPolyMesh = new Mesh ( \"high_poly.dae\" , scale ); // For close viewing // Async loading management const loader = new Mesh ( \"large_model.dae\" , scale ); loader . setLoadCompleteCallback (() => { // Enable rendering after loading robotScene . readyToRender = true ; });","title":"Optimization Strategies"},{"location":"api/geometry.html#material-integration","text":"","title":"Material Integration"},{"location":"api/geometry.html#geometry-with-materials","text":"// Primitive with solid color const box = new Box ( 1 , 1 , 1 ); const redMaterial = new Material (); redMaterial . color = new BABYLON . Color4 ( 1 , 0 , 0 , 1 ); box . create ( scene , redMaterial ); // Mesh with texture (material can be embedded in file) const texturedMesh = new Mesh ( \"textured_model.dae\" , scale ); texturedMesh . create ( scene , undefined ); // Uses embedded materials // Mesh with override material const meshWithOverride = new Mesh ( \"model.dae\" , scale ); meshWithOverride . create ( scene , customMaterial ); // Overrides embedded materials","title":"Geometry with Materials"},{"location":"api/geometry.html#error-handling","text":"","title":"Error Handling"},{"location":"api/geometry.html#file-loading-errors","text":"const mesh = new Mesh ( \"missing_file.dae\" , scale ); mesh . setLoadCompleteCallback (() => { if ( mesh . meshes && mesh . meshes . length > 0 ) { console . log ( \"Mesh loaded successfully\" ); } else { console . error ( \"Failed to load mesh\" ); } });","title":"File Loading Errors"},{"location":"api/geometry.html#disposal-and-cleanup","text":"// Always dispose geometries to prevent memory leaks geometry . dispose (); // For meshes, this cleans up: // - Loaded mesh data // - Transform nodes // - Associated materials (if not shared) // - Animation data","title":"Disposal and Cleanup"},{"location":"api/geometry.html#integration-with-robot-components","text":"Geometries are typically used within Visual components: // Part of robot loading process const link = new Link (); const visual = new Visual (); // Choose appropriate geometry visual . geometry = new Box ( 1 , 0.5 , 0.3 ); // Simple box // OR visual . geometry = new Mesh ( \"complex_part.dae\" , scale ); // Complex mesh link . visuals . push ( visual ); This creates a complete chain: Robot \u2192 Link \u2192 Visual \u2192 Geometry \u2192 Babylon.js Mesh","title":"Integration with Robot Components"},{"location":"api/gizmos.html","text":"Gizmos API Interactive manipulation tools for robot joints, providing visual controls for position and rotation adjustments. JointPositionGizmo A specialized gizmo for manipulating joint positions along their motion axis. Constructor const positionGizmo = new JointPositionGizmo ( joint , color , utilityLayer ); Parameters: - joint : Joint - The joint to manipulate - color : BABYLON.Color3 - Gizmo color - utilityLayer : BABYLON.UtilityLayerRenderer - Rendering layer Properties Property Type Description dragBehavior BABYLON.PointerDragBehavior Handles drag interactions snapDistance number Distance snapping increment (default: 0) onSnapObservable BABYLON.Observable Event fired when snapping occurs associatedJoint Joint \\| undefined The joint being manipulated coloredMaterial BABYLON.StandardMaterial Default appearance material hoverMaterial BABYLON.StandardMaterial Hover state material disableMaterial BABYLON.StandardMaterial Disabled state material Usage Example import { JointPositionGizmo } from '@ranchhandrobotics/babylon_ros' ; // Create position gizmo for a prismatic joint const linearJoint = robot . joints . get ( \"linear_actuator\" ); if ( linearJoint && linearJoint . type === JointType . Prismatic ) { const positionGizmo = new JointPositionGizmo ( linearJoint , BABYLON . Color3 . Blue (), // Blue color for Z-axis utilityLayer ); // Configure snapping positionGizmo . snapDistance = 0.01 ; // 1cm increments // Listen for position changes positionGizmo . dragBehavior . onDragObservable . add (() => { console . log ( `Joint position: ${ linearJoint . transform ? . position } ` ); }); // Attach to joint positionGizmo . attachedNode = linearJoint . transform ; } JointRotationGizmo A specialized gizmo for manipulating joint rotations around their axis. Constructor const rotationGizmo = new JointRotationGizmo ( joint , color , utilityLayer ); Parameters: - joint : Joint - The joint to manipulate - color : BABYLON.Color3 - Gizmo color - utilityLayer : BABYLON.UtilityLayerRenderer - Rendering layer Properties Property Type Description dragBehavior BABYLON.PointerDragBehavior Handles drag interactions snapDistance number Angular snapping increment in radians (default: 0) onSnapObservable BABYLON.Observable Event fired when snapping occurs angle number Accumulated rotation angle (reset on drag start) sensitivity number Drag sensitivity multiplier (default: 1) enableLimits boolean Whether to enforce joint limits (default: true) associatedJoint Joint \\| undefined The joint being manipulated MaxDragAngle number (static) Maximum camera angle for interaction Usage Example import { JointRotationGizmo } from '@ranchhandrobotics/babylon_ros' ; // Create rotation gizmo for a revolute joint const shoulderJoint = robot . joints . get ( \"shoulder_joint\" ); if ( shoulderJoint && shoulderJoint . type === JointType . Revolute ) { const rotationGizmo = new JointRotationGizmo ( shoulderJoint , BABYLON . Color3 . Red (), // Red color for X-axis rotation utilityLayer ); // Configure snapping to 15-degree increments rotationGizmo . snapDistance = Math . PI / 12 ; // 15 degrees // Enable joint limits rotationGizmo . enableLimits = true ; // Adjust sensitivity for finer control rotationGizmo . sensitivity = 0.5 ; // Listen for rotation changes rotationGizmo . dragBehavior . onDragObservable . add (() => { console . log ( `Joint angle: ${ rotationGizmo . angle } radians` ); }); // Attach to joint rotationGizmo . attachedNode = shoulderJoint . transform ; } Gizmo Color Conventions Standard color coding for different axes and joint types: // Axis-based colors (following RGB = XYZ convention) const xAxisColor = BABYLON . Color3 . Red (); // X-axis: Red const yAxisColor = BABYLON . Color3 . Green (); // Y-axis: Green const zAxisColor = BABYLON . Color3 . Blue (); // Z-axis: Blue // Joint type colors const revoluteColor = BABYLON . Color3 . Yellow (); // Revolute joints const prismaticColor = BABYLON . Color3 . Cyan (); // Prismatic joints const continuousColor = BABYLON . Color3 . Magenta (); // Continuous joints Automatic Gizmo Creation The RobotScene class provides automatic gizmo creation based on joint properties: // Automatic gizmo creation in RobotScene addExerciseGizmoToJoint ( joint : Joint , scene : BABYLON.Scene , layer : BABYLON.UtilityLayerRenderer ) { if ( joint . type === JointType . Fixed ) { return ; // No gizmo for fixed joints } switch ( joint . type ) { case JointType.Revolute : case JointType . Continuous : // Create rotation gizmo based on axis if ( Math . abs ( joint . axis . y ) > 0.5 ) { // Y-axis rotation - use green gizmo this . planeRotationGizmo = new JointRotationGizmo ( joint , BABYLON . Color3 . Green (), layer ); } else if ( Math . abs ( joint . axis . z ) > 0.5 ) { // Z-axis rotation - use blue gizmo this . planeRotationGizmo = new JointRotationGizmo ( joint , BABYLON . Color3 . Blue (), layer ); } else { // X-axis rotation - use red gizmo this . planeRotationGizmo = new JointRotationGizmo ( joint , BABYLON . Color3 . Red (), layer ); } break ; case JointType . Prismatic : // Create position gizmo based on axis this . planePositionGizmo = new JointPositionGizmo ( joint , BABYLON . Color3 . Cyan (), layer ); break ; } } Gizmo Interaction Drag Events Both gizmo types provide drag event observables: // Position gizmo drag handling positionGizmo . dragBehavior . onDragStartObservable . add (() => { console . log ( \"Started dragging position\" ); }); positionGizmo . dragBehavior . onDragObservable . add (() => { // Update joint position if ( joint . transform ) { const position = joint . transform . position ; console . log ( `Position: ${ position . x } , ${ position . y } , ${ position . z } ` ); } }); positionGizmo . dragBehavior . onDragEndObservable . add (() => { console . log ( \"Finished dragging position\" ); }); // Rotation gizmo drag handling rotationGizmo . dragBehavior . onDragObservable . add (() => { console . log ( `Rotation angle: ${ rotationGizmo . angle } radians` ); console . log ( `Rotation degrees: ${ rotationGizmo . angle * 180 / Math . PI } \u00b0` ); }); Snapping Events Handle snapping for precise control: // Position snapping positionGizmo . snapDistance = 0.005 ; // 5mm increments positionGizmo . onSnapObservable . add (( snapInfo ) => { console . log ( `Snapped by ${ snapInfo . snapDistance } units` ); }); // Rotation snapping rotationGizmo . snapDistance = Math . PI / 36 ; // 5-degree increments rotationGizmo . onSnapObservable . add (( snapInfo ) => { const degrees = snapInfo . snapDistance * 180 / Math . PI ; console . log ( `Snapped by ${ degrees } degrees` ); }); Joint Limits Enforcement Rotation Limits const rotationGizmo = new JointRotationGizmo ( joint , color , layer ); // Enable limit checking rotationGizmo . enableLimits = true ; // Limits are automatically read from joint properties console . log ( `Joint limits: ${ joint . lowerLimit } to ${ joint . upperLimit } radians` ); // The gizmo will prevent movement beyond these limits rotationGizmo . dragBehavior . onDragObservable . add (() => { if ( rotationGizmo . enableLimits ) { // Clamp angle to joint limits const clampedAngle = Math . max ( joint . lowerLimit , Math . min ( joint . upperLimit , rotationGizmo . angle )); if ( clampedAngle !== rotationGizmo . angle ) { console . log ( \"Hit joint limit!\" ); } } }); Position Limits const positionGizmo = new JointPositionGizmo ( joint , color , layer ); // For prismatic joints, limits apply to translation distance positionGizmo . dragBehavior . onDragObservable . add (() => { if ( joint . transform ) { const distance = joint . transform . position . length (); if ( distance < joint . lowerLimit || distance > joint . upperLimit ) { console . log ( \"Position outside joint limits!\" ); } } }); Material States Gizmos provide different visual states: // Access different material states const gizmo = new JointRotationGizmo ( joint , color , layer ); // Default state - colored material console . log ( gizmo . coloredMaterial . name ); // Hover state - brighter/highlighted material gizmo . _gizmoMesh . actionManager = new BABYLON . ActionManager ( scene ); gizmo . _gizmoMesh . actionManager . registerAction ( new BABYLON . ExecuteCodeAction ( BABYLON . ActionManager . OnPointerOverTrigger , () => { gizmo . _gizmoMesh . material = gizmo . hoverMaterial ; }) ); // Disabled state - grayed out material if ( joint . type === JointType . Fixed ) { gizmo . _gizmoMesh . material = gizmo . disableMaterial ; } Performance Considerations Utility Layer Management // Use shared utility layer for multiple gizmos const utilityLayer = new BABYLON . UtilityLayerRenderer ( scene ); // Create multiple gizmos on same layer const gizmo1 = new JointRotationGizmo ( joint1 , color , utilityLayer ); const gizmo2 = new JointPositionGizmo ( joint2 , color , utilityLayer ); // Proper cleanup gizmo1 . dispose (); gizmo2 . dispose (); utilityLayer . dispose (); Selective Gizmo Activation // Only show gizmos for selected joints function showGizmosForJoint ( selectedJoint : Joint ) { // Clear existing gizmos clearAllGizmos (); // Create gizmo only for selected joint if ( selectedJoint . type !== JointType . Fixed ) { createGizmoForJoint ( selectedJoint ); } } Integration with RobotScene Gizmos are typically managed by the RobotScene class: // Toggle joint exercise mode robotScene . clearJointExerciseGizmos (); // Clear existing robotScene . addExerciseGizmoToJoint ( selectedJoint , scene , utilityLayer ); // Gizmos automatically: // - Choose appropriate type based on joint // - Use proper colors for axes // - Enforce joint limits // - Handle coordinate system conversions","title":"Gizmos"},{"location":"api/gizmos.html#gizmos-api","text":"Interactive manipulation tools for robot joints, providing visual controls for position and rotation adjustments.","title":"Gizmos API"},{"location":"api/gizmos.html#jointpositiongizmo","text":"A specialized gizmo for manipulating joint positions along their motion axis.","title":"JointPositionGizmo"},{"location":"api/gizmos.html#constructor","text":"const positionGizmo = new JointPositionGizmo ( joint , color , utilityLayer ); Parameters: - joint : Joint - The joint to manipulate - color : BABYLON.Color3 - Gizmo color - utilityLayer : BABYLON.UtilityLayerRenderer - Rendering layer","title":"Constructor"},{"location":"api/gizmos.html#properties","text":"Property Type Description dragBehavior BABYLON.PointerDragBehavior Handles drag interactions snapDistance number Distance snapping increment (default: 0) onSnapObservable BABYLON.Observable Event fired when snapping occurs associatedJoint Joint \\| undefined The joint being manipulated coloredMaterial BABYLON.StandardMaterial Default appearance material hoverMaterial BABYLON.StandardMaterial Hover state material disableMaterial BABYLON.StandardMaterial Disabled state material","title":"Properties"},{"location":"api/gizmos.html#usage-example","text":"import { JointPositionGizmo } from '@ranchhandrobotics/babylon_ros' ; // Create position gizmo for a prismatic joint const linearJoint = robot . joints . get ( \"linear_actuator\" ); if ( linearJoint && linearJoint . type === JointType . Prismatic ) { const positionGizmo = new JointPositionGizmo ( linearJoint , BABYLON . Color3 . Blue (), // Blue color for Z-axis utilityLayer ); // Configure snapping positionGizmo . snapDistance = 0.01 ; // 1cm increments // Listen for position changes positionGizmo . dragBehavior . onDragObservable . add (() => { console . log ( `Joint position: ${ linearJoint . transform ? . position } ` ); }); // Attach to joint positionGizmo . attachedNode = linearJoint . transform ; }","title":"Usage Example"},{"location":"api/gizmos.html#jointrotationgizmo","text":"A specialized gizmo for manipulating joint rotations around their axis.","title":"JointRotationGizmo"},{"location":"api/gizmos.html#constructor_1","text":"const rotationGizmo = new JointRotationGizmo ( joint , color , utilityLayer ); Parameters: - joint : Joint - The joint to manipulate - color : BABYLON.Color3 - Gizmo color - utilityLayer : BABYLON.UtilityLayerRenderer - Rendering layer","title":"Constructor"},{"location":"api/gizmos.html#properties_1","text":"Property Type Description dragBehavior BABYLON.PointerDragBehavior Handles drag interactions snapDistance number Angular snapping increment in radians (default: 0) onSnapObservable BABYLON.Observable Event fired when snapping occurs angle number Accumulated rotation angle (reset on drag start) sensitivity number Drag sensitivity multiplier (default: 1) enableLimits boolean Whether to enforce joint limits (default: true) associatedJoint Joint \\| undefined The joint being manipulated MaxDragAngle number (static) Maximum camera angle for interaction","title":"Properties"},{"location":"api/gizmos.html#usage-example_1","text":"import { JointRotationGizmo } from '@ranchhandrobotics/babylon_ros' ; // Create rotation gizmo for a revolute joint const shoulderJoint = robot . joints . get ( \"shoulder_joint\" ); if ( shoulderJoint && shoulderJoint . type === JointType . Revolute ) { const rotationGizmo = new JointRotationGizmo ( shoulderJoint , BABYLON . Color3 . Red (), // Red color for X-axis rotation utilityLayer ); // Configure snapping to 15-degree increments rotationGizmo . snapDistance = Math . PI / 12 ; // 15 degrees // Enable joint limits rotationGizmo . enableLimits = true ; // Adjust sensitivity for finer control rotationGizmo . sensitivity = 0.5 ; // Listen for rotation changes rotationGizmo . dragBehavior . onDragObservable . add (() => { console . log ( `Joint angle: ${ rotationGizmo . angle } radians` ); }); // Attach to joint rotationGizmo . attachedNode = shoulderJoint . transform ; }","title":"Usage Example"},{"location":"api/gizmos.html#gizmo-color-conventions","text":"Standard color coding for different axes and joint types: // Axis-based colors (following RGB = XYZ convention) const xAxisColor = BABYLON . Color3 . Red (); // X-axis: Red const yAxisColor = BABYLON . Color3 . Green (); // Y-axis: Green const zAxisColor = BABYLON . Color3 . Blue (); // Z-axis: Blue // Joint type colors const revoluteColor = BABYLON . Color3 . Yellow (); // Revolute joints const prismaticColor = BABYLON . Color3 . Cyan (); // Prismatic joints const continuousColor = BABYLON . Color3 . Magenta (); // Continuous joints","title":"Gizmo Color Conventions"},{"location":"api/gizmos.html#automatic-gizmo-creation","text":"The RobotScene class provides automatic gizmo creation based on joint properties: // Automatic gizmo creation in RobotScene addExerciseGizmoToJoint ( joint : Joint , scene : BABYLON.Scene , layer : BABYLON.UtilityLayerRenderer ) { if ( joint . type === JointType . Fixed ) { return ; // No gizmo for fixed joints } switch ( joint . type ) { case JointType.Revolute : case JointType . Continuous : // Create rotation gizmo based on axis if ( Math . abs ( joint . axis . y ) > 0.5 ) { // Y-axis rotation - use green gizmo this . planeRotationGizmo = new JointRotationGizmo ( joint , BABYLON . Color3 . Green (), layer ); } else if ( Math . abs ( joint . axis . z ) > 0.5 ) { // Z-axis rotation - use blue gizmo this . planeRotationGizmo = new JointRotationGizmo ( joint , BABYLON . Color3 . Blue (), layer ); } else { // X-axis rotation - use red gizmo this . planeRotationGizmo = new JointRotationGizmo ( joint , BABYLON . Color3 . Red (), layer ); } break ; case JointType . Prismatic : // Create position gizmo based on axis this . planePositionGizmo = new JointPositionGizmo ( joint , BABYLON . Color3 . Cyan (), layer ); break ; } }","title":"Automatic Gizmo Creation"},{"location":"api/gizmos.html#gizmo-interaction","text":"","title":"Gizmo Interaction"},{"location":"api/gizmos.html#drag-events","text":"Both gizmo types provide drag event observables: // Position gizmo drag handling positionGizmo . dragBehavior . onDragStartObservable . add (() => { console . log ( \"Started dragging position\" ); }); positionGizmo . dragBehavior . onDragObservable . add (() => { // Update joint position if ( joint . transform ) { const position = joint . transform . position ; console . log ( `Position: ${ position . x } , ${ position . y } , ${ position . z } ` ); } }); positionGizmo . dragBehavior . onDragEndObservable . add (() => { console . log ( \"Finished dragging position\" ); }); // Rotation gizmo drag handling rotationGizmo . dragBehavior . onDragObservable . add (() => { console . log ( `Rotation angle: ${ rotationGizmo . angle } radians` ); console . log ( `Rotation degrees: ${ rotationGizmo . angle * 180 / Math . PI } \u00b0` ); });","title":"Drag Events"},{"location":"api/gizmos.html#snapping-events","text":"Handle snapping for precise control: // Position snapping positionGizmo . snapDistance = 0.005 ; // 5mm increments positionGizmo . onSnapObservable . add (( snapInfo ) => { console . log ( `Snapped by ${ snapInfo . snapDistance } units` ); }); // Rotation snapping rotationGizmo . snapDistance = Math . PI / 36 ; // 5-degree increments rotationGizmo . onSnapObservable . add (( snapInfo ) => { const degrees = snapInfo . snapDistance * 180 / Math . PI ; console . log ( `Snapped by ${ degrees } degrees` ); });","title":"Snapping Events"},{"location":"api/gizmos.html#joint-limits-enforcement","text":"","title":"Joint Limits Enforcement"},{"location":"api/gizmos.html#rotation-limits","text":"const rotationGizmo = new JointRotationGizmo ( joint , color , layer ); // Enable limit checking rotationGizmo . enableLimits = true ; // Limits are automatically read from joint properties console . log ( `Joint limits: ${ joint . lowerLimit } to ${ joint . upperLimit } radians` ); // The gizmo will prevent movement beyond these limits rotationGizmo . dragBehavior . onDragObservable . add (() => { if ( rotationGizmo . enableLimits ) { // Clamp angle to joint limits const clampedAngle = Math . max ( joint . lowerLimit , Math . min ( joint . upperLimit , rotationGizmo . angle )); if ( clampedAngle !== rotationGizmo . angle ) { console . log ( \"Hit joint limit!\" ); } } });","title":"Rotation Limits"},{"location":"api/gizmos.html#position-limits","text":"const positionGizmo = new JointPositionGizmo ( joint , color , layer ); // For prismatic joints, limits apply to translation distance positionGizmo . dragBehavior . onDragObservable . add (() => { if ( joint . transform ) { const distance = joint . transform . position . length (); if ( distance < joint . lowerLimit || distance > joint . upperLimit ) { console . log ( \"Position outside joint limits!\" ); } } });","title":"Position Limits"},{"location":"api/gizmos.html#material-states","text":"Gizmos provide different visual states: // Access different material states const gizmo = new JointRotationGizmo ( joint , color , layer ); // Default state - colored material console . log ( gizmo . coloredMaterial . name ); // Hover state - brighter/highlighted material gizmo . _gizmoMesh . actionManager = new BABYLON . ActionManager ( scene ); gizmo . _gizmoMesh . actionManager . registerAction ( new BABYLON . ExecuteCodeAction ( BABYLON . ActionManager . OnPointerOverTrigger , () => { gizmo . _gizmoMesh . material = gizmo . hoverMaterial ; }) ); // Disabled state - grayed out material if ( joint . type === JointType . Fixed ) { gizmo . _gizmoMesh . material = gizmo . disableMaterial ; }","title":"Material States"},{"location":"api/gizmos.html#performance-considerations","text":"","title":"Performance Considerations"},{"location":"api/gizmos.html#utility-layer-management","text":"// Use shared utility layer for multiple gizmos const utilityLayer = new BABYLON . UtilityLayerRenderer ( scene ); // Create multiple gizmos on same layer const gizmo1 = new JointRotationGizmo ( joint1 , color , utilityLayer ); const gizmo2 = new JointPositionGizmo ( joint2 , color , utilityLayer ); // Proper cleanup gizmo1 . dispose (); gizmo2 . dispose (); utilityLayer . dispose ();","title":"Utility Layer Management"},{"location":"api/gizmos.html#selective-gizmo-activation","text":"// Only show gizmos for selected joints function showGizmosForJoint ( selectedJoint : Joint ) { // Clear existing gizmos clearAllGizmos (); // Create gizmo only for selected joint if ( selectedJoint . type !== JointType . Fixed ) { createGizmoForJoint ( selectedJoint ); } }","title":"Selective Gizmo Activation"},{"location":"api/gizmos.html#integration-with-robotscene","text":"Gizmos are typically managed by the RobotScene class: // Toggle joint exercise mode robotScene . clearJointExerciseGizmos (); // Clear existing robotScene . addExerciseGizmoToJoint ( selectedJoint , scene , utilityLayer ); // Gizmos automatically: // - Choose appropriate type based on joint // - Use proper colors for axes // - Enforce joint limits // - Handle coordinate system conversions","title":"Integration with RobotScene"},{"location":"api/joint.html","text":"Joint API The Joint class represents a robotic joint that connects two links and defines their relative motion constraints. JointType Enum enum JointType { Fixed = \"fixed\" , Revolute = \"revolute\" , Continuous = \"continuous\" , Prismatic = \"prismatic\" , Floating = \"floating\" , Planar = \"planar\" } Defines the types of joints supported: - Fixed : No relative motion allowed - Revolute : Rotation around a single axis with limits - Continuous : Unlimited rotation around a single axis - Prismatic : Linear motion along a single axis - Floating : 6 degrees of freedom (not commonly used) - Planar : Motion in a 2D plane (not commonly used) Constructor const joint = new Joint (); Creates a new Joint instance with default values. Properties Public Properties Property Type Description name string The joint's unique name type JointType The type of joint motion origin BABYLON.Vector3 Position offset from parent link rpy BABYLON.Vector3 Roll, pitch, yaw rotation (in radians) axis BABYLON.Vector3 Axis of rotation/translation transform BABYLON.TransformNode \\| undefined The 3D transform node parentName string Name of the parent link childName string Name of the child link parent Link \\| undefined Reference to parent link object child Link \\| undefined Reference to child link object lowerLimit number Lower motion limit (radians or meters) upperLimit number Upper motion limit (radians or meters) Methods Lifecycle Methods create(scene: BABYLON.Scene, materialMap: Map<string, Material>): void Creates the joint's transform node in the 3D scene and applies positioning. Parameters: - scene : BABYLON.Scene - The Babylon.js scene - materialMap : Map - Available materials (not used by joints) Behavior: - Creates a TransformNode with the joint's name - Applies the origin position - Applies roll-pitch-yaw rotation using utility functions Example: joint . create ( scene , materialMap ); dispose(): void Cleans up the joint's transform node and releases resources. Example: joint . dispose (); Usage Examples Creating a Revolute Joint import { Joint , JointType } from '@ranchhandrobotics/babylon_ros' ; const wheelJoint = new Joint (); wheelJoint . name = \"wheel_joint\" ; wheelJoint . type = JointType . Revolute ; wheelJoint . origin = new BABYLON . Vector3 ( 0 , 0 , 0.1 ); // 10cm offset wheelJoint . axis = new BABYLON . Vector3 ( 0 , 1 , 0 ); // Y-axis rotation wheelJoint . lowerLimit = - Math . PI ; // -180 degrees wheelJoint . upperLimit = Math . PI ; // +180 degrees wheelJoint . create ( scene , materialMap ); Creating a Prismatic Joint const linearJoint = new Joint (); linearJoint . name = \"linear_actuator\" ; linearJoint . type = JointType . Prismatic ; linearJoint . axis = new BABYLON . Vector3 ( 0 , 0 , 1 ); // Z-axis translation linearJoint . lowerLimit = 0 ; // 0 meters linearJoint . upperLimit = 0.5 ; // 50cm extension linearJoint . create ( scene , materialMap ); Accessing Joint Properties // Check joint type if ( joint . type === JointType . Revolute ) { console . log ( `Revolute joint with limits: ${ joint . lowerLimit } to ${ joint . upperLimit } ` ); } // Get joint position in world coordinates if ( joint . transform ) { const worldPosition = joint . transform . getAbsolutePosition (); console . log ( `Joint world position: ${ worldPosition } ` ); } // Check parent-child relationships console . log ( ` ${ joint . name } connects ${ joint . parentName } to ${ joint . childName } ` ); Joint Types in Detail Fixed Joints joint . type = JointType . Fixed ; // No motion allowed - acts like a rigid connection // Commonly used for sensors, decorative elements Revolute Joints joint . type = JointType . Revolute ; joint . axis = new BABYLON . Vector3 ( 0 , 1 , 0 ); // Rotation around Y-axis joint . lowerLimit = - Math . PI / 2 ; // -90 degrees joint . upperLimit = Math . PI / 2 ; // +90 degrees // Common for robot arms, wheels with steering Continuous Joints joint . type = JointType . Continuous ; joint . axis = new BABYLON . Vector3 ( 0 , 0 , 1 ); // Rotation around Z-axis // No limits - can rotate infinitely // Common for drive wheels, rotating sensors Prismatic Joints joint . type = JointType . Prismatic ; joint . axis = new BABYLON . Vector3 ( 1 , 0 , 0 ); // Translation along X-axis joint . lowerLimit = 0 ; // Minimum extension joint . upperLimit = 1.0 ; // Maximum extension (1 meter) // Common for linear actuators, telescoping parts Coordinate Systems Origin and Position origin : Position relative to parent link's coordinate frame Applied before rotation Units are in meters Roll-Pitch-Yaw (RPY) rpy.x : Roll around X-axis (radians) rpy.y : Pitch around Y-axis (radians) rpy.z : Yaw around Z-axis (radians) Applied in order: Roll, then Pitch, then Yaw Axis Vector axis : Unit vector defining motion direction For revolute/continuous: axis of rotation For prismatic: direction of translation Common axes: (1,0,0) : X-axis (0,1,0) : Y-axis (0,0,1) : Z-axis Limits and Constraints Motion Limits lowerLimit : Minimum allowed position/angle upperLimit : Maximum allowed position/angle Units: radians for revolute/continuous, meters for prismatic Fixed joints ignore limits Limit Examples // Robot arm elbow joint (120\u00b0 range) joint . lowerLimit = - Math . PI / 3 ; // -60\u00b0 joint . upperLimit = Math . PI / 3 ; // +60\u00b0 // Linear slide (0-30cm extension) joint . lowerLimit = 0 ; // Fully retracted joint . upperLimit = 0.3 ; // 30cm extended Integration with Robot Joints are typically created as part of robot loading: // Joints are populated from URDF const robot = urdf . loadRobot ( urdfDoc , scene , {}); // Access joint after loading const joint = robot . joints . get ( \"wheel_joint\" ); if ( joint ) { console . log ( `Joint type: ${ joint . type } ` ); console . log ( `Connects: ${ joint . parentName } -> ${ joint . childName } ` ); } Transform Hierarchy The joint transform establishes the kinematic chain: 1. Parent Link \u2192 Joint Transform \u2192 Child Link 2. Joint motion affects all child transforms 3. Multiple joints can create complex kinematic chains // Example kinematic chain // base_link -> shoulder_joint -> upper_arm -> elbow_joint -> forearm if ( joint . parent && joint . child ) { console . log ( `Chain: ${ joint . parent . name } -> ${ joint . name } -> ${ joint . child . name } ` ); }","title":"Joint"},{"location":"api/joint.html#joint-api","text":"The Joint class represents a robotic joint that connects two links and defines their relative motion constraints.","title":"Joint API"},{"location":"api/joint.html#jointtype-enum","text":"enum JointType { Fixed = \"fixed\" , Revolute = \"revolute\" , Continuous = \"continuous\" , Prismatic = \"prismatic\" , Floating = \"floating\" , Planar = \"planar\" } Defines the types of joints supported: - Fixed : No relative motion allowed - Revolute : Rotation around a single axis with limits - Continuous : Unlimited rotation around a single axis - Prismatic : Linear motion along a single axis - Floating : 6 degrees of freedom (not commonly used) - Planar : Motion in a 2D plane (not commonly used)","title":"JointType Enum"},{"location":"api/joint.html#constructor","text":"const joint = new Joint (); Creates a new Joint instance with default values.","title":"Constructor"},{"location":"api/joint.html#properties","text":"","title":"Properties"},{"location":"api/joint.html#public-properties","text":"Property Type Description name string The joint's unique name type JointType The type of joint motion origin BABYLON.Vector3 Position offset from parent link rpy BABYLON.Vector3 Roll, pitch, yaw rotation (in radians) axis BABYLON.Vector3 Axis of rotation/translation transform BABYLON.TransformNode \\| undefined The 3D transform node parentName string Name of the parent link childName string Name of the child link parent Link \\| undefined Reference to parent link object child Link \\| undefined Reference to child link object lowerLimit number Lower motion limit (radians or meters) upperLimit number Upper motion limit (radians or meters)","title":"Public Properties"},{"location":"api/joint.html#methods","text":"","title":"Methods"},{"location":"api/joint.html#lifecycle-methods","text":"","title":"Lifecycle Methods"},{"location":"api/joint.html#createscene-babylonscene-materialmap-mapstring-material-void","text":"Creates the joint's transform node in the 3D scene and applies positioning. Parameters: - scene : BABYLON.Scene - The Babylon.js scene - materialMap : Map - Available materials (not used by joints) Behavior: - Creates a TransformNode with the joint's name - Applies the origin position - Applies roll-pitch-yaw rotation using utility functions Example: joint . create ( scene , materialMap );","title":"create(scene: BABYLON.Scene, materialMap: Map&lt;string, Material&gt;): void"},{"location":"api/joint.html#dispose-void","text":"Cleans up the joint's transform node and releases resources. Example: joint . dispose ();","title":"dispose(): void"},{"location":"api/joint.html#usage-examples","text":"","title":"Usage Examples"},{"location":"api/joint.html#creating-a-revolute-joint","text":"import { Joint , JointType } from '@ranchhandrobotics/babylon_ros' ; const wheelJoint = new Joint (); wheelJoint . name = \"wheel_joint\" ; wheelJoint . type = JointType . Revolute ; wheelJoint . origin = new BABYLON . Vector3 ( 0 , 0 , 0.1 ); // 10cm offset wheelJoint . axis = new BABYLON . Vector3 ( 0 , 1 , 0 ); // Y-axis rotation wheelJoint . lowerLimit = - Math . PI ; // -180 degrees wheelJoint . upperLimit = Math . PI ; // +180 degrees wheelJoint . create ( scene , materialMap );","title":"Creating a Revolute Joint"},{"location":"api/joint.html#creating-a-prismatic-joint","text":"const linearJoint = new Joint (); linearJoint . name = \"linear_actuator\" ; linearJoint . type = JointType . Prismatic ; linearJoint . axis = new BABYLON . Vector3 ( 0 , 0 , 1 ); // Z-axis translation linearJoint . lowerLimit = 0 ; // 0 meters linearJoint . upperLimit = 0.5 ; // 50cm extension linearJoint . create ( scene , materialMap );","title":"Creating a Prismatic Joint"},{"location":"api/joint.html#accessing-joint-properties","text":"// Check joint type if ( joint . type === JointType . Revolute ) { console . log ( `Revolute joint with limits: ${ joint . lowerLimit } to ${ joint . upperLimit } ` ); } // Get joint position in world coordinates if ( joint . transform ) { const worldPosition = joint . transform . getAbsolutePosition (); console . log ( `Joint world position: ${ worldPosition } ` ); } // Check parent-child relationships console . log ( ` ${ joint . name } connects ${ joint . parentName } to ${ joint . childName } ` );","title":"Accessing Joint Properties"},{"location":"api/joint.html#joint-types-in-detail","text":"","title":"Joint Types in Detail"},{"location":"api/joint.html#fixed-joints","text":"joint . type = JointType . Fixed ; // No motion allowed - acts like a rigid connection // Commonly used for sensors, decorative elements","title":"Fixed Joints"},{"location":"api/joint.html#revolute-joints","text":"joint . type = JointType . Revolute ; joint . axis = new BABYLON . Vector3 ( 0 , 1 , 0 ); // Rotation around Y-axis joint . lowerLimit = - Math . PI / 2 ; // -90 degrees joint . upperLimit = Math . PI / 2 ; // +90 degrees // Common for robot arms, wheels with steering","title":"Revolute Joints"},{"location":"api/joint.html#continuous-joints","text":"joint . type = JointType . Continuous ; joint . axis = new BABYLON . Vector3 ( 0 , 0 , 1 ); // Rotation around Z-axis // No limits - can rotate infinitely // Common for drive wheels, rotating sensors","title":"Continuous Joints"},{"location":"api/joint.html#prismatic-joints","text":"joint . type = JointType . Prismatic ; joint . axis = new BABYLON . Vector3 ( 1 , 0 , 0 ); // Translation along X-axis joint . lowerLimit = 0 ; // Minimum extension joint . upperLimit = 1.0 ; // Maximum extension (1 meter) // Common for linear actuators, telescoping parts","title":"Prismatic Joints"},{"location":"api/joint.html#coordinate-systems","text":"","title":"Coordinate Systems"},{"location":"api/joint.html#origin-and-position","text":"origin : Position relative to parent link's coordinate frame Applied before rotation Units are in meters","title":"Origin and Position"},{"location":"api/joint.html#roll-pitch-yaw-rpy","text":"rpy.x : Roll around X-axis (radians) rpy.y : Pitch around Y-axis (radians) rpy.z : Yaw around Z-axis (radians) Applied in order: Roll, then Pitch, then Yaw","title":"Roll-Pitch-Yaw (RPY)"},{"location":"api/joint.html#axis-vector","text":"axis : Unit vector defining motion direction For revolute/continuous: axis of rotation For prismatic: direction of translation Common axes: (1,0,0) : X-axis (0,1,0) : Y-axis (0,0,1) : Z-axis","title":"Axis Vector"},{"location":"api/joint.html#limits-and-constraints","text":"","title":"Limits and Constraints"},{"location":"api/joint.html#motion-limits","text":"lowerLimit : Minimum allowed position/angle upperLimit : Maximum allowed position/angle Units: radians for revolute/continuous, meters for prismatic Fixed joints ignore limits","title":"Motion Limits"},{"location":"api/joint.html#limit-examples","text":"// Robot arm elbow joint (120\u00b0 range) joint . lowerLimit = - Math . PI / 3 ; // -60\u00b0 joint . upperLimit = Math . PI / 3 ; // +60\u00b0 // Linear slide (0-30cm extension) joint . lowerLimit = 0 ; // Fully retracted joint . upperLimit = 0.3 ; // 30cm extended","title":"Limit Examples"},{"location":"api/joint.html#integration-with-robot","text":"Joints are typically created as part of robot loading: // Joints are populated from URDF const robot = urdf . loadRobot ( urdfDoc , scene , {}); // Access joint after loading const joint = robot . joints . get ( \"wheel_joint\" ); if ( joint ) { console . log ( `Joint type: ${ joint . type } ` ); console . log ( `Connects: ${ joint . parentName } -> ${ joint . childName } ` ); }","title":"Integration with Robot"},{"location":"api/joint.html#transform-hierarchy","text":"The joint transform establishes the kinematic chain: 1. Parent Link \u2192 Joint Transform \u2192 Child Link 2. Joint motion affects all child transforms 3. Multiple joints can create complex kinematic chains // Example kinematic chain // base_link -> shoulder_joint -> upper_arm -> elbow_joint -> forearm if ( joint . parent && joint . child ) { console . log ( `Chain: ${ joint . parent . name } -> ${ joint . name } -> ${ joint . child . name } ` ); }","title":"Transform Hierarchy"},{"location":"api/link.html","text":"Link API The Link class represents a physical component of a robot, containing visual and collision geometries with materials and transforms. Constructor const link = new Link (); Creates a new Link instance with empty visual and collision arrays. Properties Public Properties Property Type Description name string The link's unique name material Material \\| undefined Default material for the link transform BABYLON.TransformNode \\| undefined The 3D transform node visuals Array<Visual> Array of visual geometry components collisions Array<Visual> Array of collision geometry components Methods Lifecycle Methods create(scene: BABYLON.Scene, materialMap: Map<string, Material>): void Creates the link in the 3D scene, including all visual and collision geometries. Parameters: - scene : BABYLON.Scene - The Babylon.js scene - materialMap : Map - Available materials for the link Behavior: - Creates a TransformNode for the link - Creates all visual geometries and parents them to the link transform - Creates all collision geometries with collision material and disables them by default - Establishes proper parent-child relationships Example: link . create ( scene , materialMap ); dispose(): void Cleans up all resources used by the link, including geometries, materials, and transforms. Example: link . dispose (); Usage Examples Basic Link Creation import { Link } from '@ranchhandrobotics/babylon_ros' ; import { Visual } from '@ranchhandrobotics/babylon_ros' ; const baseLink = new Link (); baseLink . name = \"base_link\" ; // Add visual geometry const visual = new Visual (); visual . geometry = new BoxGeometry ( 1 , 1 , 0.2 ); // 1x1x0.2m box baseLink . visuals . push ( visual ); // Create in scene baseLink . create ( scene , materialMap ); Link with Multiple Visuals const armLink = new Link (); armLink . name = \"upper_arm\" ; // Main arm structure const mainVisual = new Visual (); mainVisual . geometry = new CylinderGeometry ( 0.5 , 0.05 , 0.05 ); // 50cm long, 5cm radius // Joint connector const connectorVisual = new Visual (); connectorVisual . geometry = new SphereGeometry ( 0.08 ); // 8cm radius sphere connectorVisual . origin = new BABYLON . Vector3 ( 0 , 0 , 0.25 ); // At end of arm armLink . visuals . push ( mainVisual ); armLink . visuals . push ( connectorVisual ); armLink . create ( scene , materialMap ); Link with Collision Geometry const chassisLink = new Link (); chassisLink . name = \"chassis\" ; // Visual geometry (detailed mesh) const visual = new Visual (); visual . geometry = new MeshGeometry ( \"chassis_detailed.dae\" ); chassisLink . visuals . push ( visual ); // Collision geometry (simplified box) const collision = new Visual (); collision . geometry = new BoxGeometry ( 2 , 1 , 0.5 ); // Simplified bounding box chassisLink . collisions . push ( collision ); chassisLink . create ( scene , materialMap ); Visual vs Collision Geometry Visual Geometries Purpose : What users see - detailed, textured models Rendering : Always visible by default Performance : Can be complex meshes with high polygon counts Materials : Use specified materials with textures and colors Collision Geometries Purpose : Physics simulation and collision detection Rendering : Hidden by default (can be toggled for debugging) Performance : Should be simple shapes for fast collision detection Materials : Automatically use \"collision\" material (semi-transparent) // Visual: Detailed robot arm mesh const visual = new Visual (); visual . geometry = new MeshGeometry ( \"detailed_arm.dae\" ); // Collision: Simple cylinder approximation const collision = new Visual (); collision . geometry = new CylinderGeometry ( 0.5 , 0.08 , 0.08 ); link . visuals . push ( visual ); link . collisions . push ( collision ); Transform Hierarchy Links establish the structural hierarchy of the robot: // Link transforms are managed automatically // Parent joint -> Link transform -> Child visuals/collisions if ( link . transform ) { // Move entire link (affects all visuals and collisions) link . transform . position = new BABYLON . Vector3 ( 1 , 0 , 0 ); // All child visuals inherit this transformation console . log ( `Link has ${ link . visuals . length } visuals` ); console . log ( `Link has ${ link . collisions . length } collision shapes` ); } Material Handling Default Material // Link can have a default material link . material = materialMap . get ( \"aluminum\" ); // Individual visuals can override the link material visual . material = materialMap . get ( \"red_plastic\" ); Material Priority Visual material : If specified, takes highest priority Link material : Used if visual has no specific material Default material : Used as fallback if neither is specified Collision Materials // Collision geometries automatically use collision material // This provides semi-transparent rendering for debugging const collision = new Visual (); collision . geometry = new BoxGeometry ( 1 , 1 , 1 ); // collision.material is automatically set to \"collision\" material Accessing Link Components Iterating Through Visuals for ( const visual of link . visuals ) { console . log ( `Visual at: ${ visual . origin } ` ); if ( visual . geometry ) { console . log ( `Geometry type: ${ visual . geometry . constructor . name } ` ); } } Checking Link Properties // Get link bounding box let min = new BABYLON . Vector3 ( Infinity , Infinity , Infinity ); let max = new BABYLON . Vector3 ( - Infinity , - Infinity , - Infinity ); for ( const visual of link . visuals ) { if ( visual . mesh ) { const bounds = visual . mesh . getBoundingInfo (); BABYLON . Vector3 . MinimizeInPlace ( min , bounds . boundingBox . minimumWorld ); BABYLON . Vector3 . MaximizeInPlace ( max , bounds . boundingBox . maximumWorld ); } } const size = max . subtract ( min ); console . log ( `Link bounding box: ${ size . x } x ${ size . y } x ${ size . z } ` ); Enabling/Disabling Collision Visualization // Show collision geometry for debugging for ( const collision of link . collisions ) { collision . setEnabled ( true ); } // Hide collision geometry for ( const collision of link . collisions ) { collision . setEnabled ( false ); } Integration with Robot Links are typically created as part of robot loading: // Links are populated from URDF const robot = urdf . loadRobot ( urdfDoc , scene , {}); // Access specific link const baseLink = robot . links . get ( \"base_link\" ); if ( baseLink ) { console . log ( `Base link has ${ baseLink . visuals . length } visual components` ); console . log ( `Base link has ${ baseLink . collisions . length } collision components` ); } // Iterate through all links for ( const [ name , link ] of robot . links ) { console . log ( `Link: ${ name } ` ); console . log ( ` Visuals: ${ link . visuals . length } ` ); console . log ( ` Collisions: ${ link . collisions . length } ` ); } Common Link Types Base Links // Main chassis or body of the robot const baseLink = new Link (); baseLink . name = \"base_link\" ; // Usually contains the main structural geometry Arm Links // Robot arm segments const upperArm = new Link (); upperArm . name = \"upper_arm\" ; const forearm = new Link (); forearm . name = \"forearm\" ; Sensor Links // Camera, LiDAR, or other sensor mounts const cameraLink = new Link (); cameraLink . name = \"camera_link\" ; // Often contain simple geometry for sensor housings Performance Considerations Visual Complexity : Detailed visuals are rendered, so balance quality vs performance Collision Simplicity : Keep collision geometry simple for fast physics simulation Material Sharing : Reuse materials across links to reduce memory usage Proper Disposal : Always dispose links to prevent memory leaks Error Handling The Link class provides robust error handling: - Handles missing materials gracefully with fallbacks - Safely manages transform hierarchy - Properly disposes of all child resources - Logs warnings for malformed geometry","title":"Link"},{"location":"api/link.html#link-api","text":"The Link class represents a physical component of a robot, containing visual and collision geometries with materials and transforms.","title":"Link API"},{"location":"api/link.html#constructor","text":"const link = new Link (); Creates a new Link instance with empty visual and collision arrays.","title":"Constructor"},{"location":"api/link.html#properties","text":"","title":"Properties"},{"location":"api/link.html#public-properties","text":"Property Type Description name string The link's unique name material Material \\| undefined Default material for the link transform BABYLON.TransformNode \\| undefined The 3D transform node visuals Array<Visual> Array of visual geometry components collisions Array<Visual> Array of collision geometry components","title":"Public Properties"},{"location":"api/link.html#methods","text":"","title":"Methods"},{"location":"api/link.html#lifecycle-methods","text":"","title":"Lifecycle Methods"},{"location":"api/link.html#createscene-babylonscene-materialmap-mapstring-material-void","text":"Creates the link in the 3D scene, including all visual and collision geometries. Parameters: - scene : BABYLON.Scene - The Babylon.js scene - materialMap : Map - Available materials for the link Behavior: - Creates a TransformNode for the link - Creates all visual geometries and parents them to the link transform - Creates all collision geometries with collision material and disables them by default - Establishes proper parent-child relationships Example: link . create ( scene , materialMap );","title":"create(scene: BABYLON.Scene, materialMap: Map&lt;string, Material&gt;): void"},{"location":"api/link.html#dispose-void","text":"Cleans up all resources used by the link, including geometries, materials, and transforms. Example: link . dispose ();","title":"dispose(): void"},{"location":"api/link.html#usage-examples","text":"","title":"Usage Examples"},{"location":"api/link.html#basic-link-creation","text":"import { Link } from '@ranchhandrobotics/babylon_ros' ; import { Visual } from '@ranchhandrobotics/babylon_ros' ; const baseLink = new Link (); baseLink . name = \"base_link\" ; // Add visual geometry const visual = new Visual (); visual . geometry = new BoxGeometry ( 1 , 1 , 0.2 ); // 1x1x0.2m box baseLink . visuals . push ( visual ); // Create in scene baseLink . create ( scene , materialMap );","title":"Basic Link Creation"},{"location":"api/link.html#link-with-multiple-visuals","text":"const armLink = new Link (); armLink . name = \"upper_arm\" ; // Main arm structure const mainVisual = new Visual (); mainVisual . geometry = new CylinderGeometry ( 0.5 , 0.05 , 0.05 ); // 50cm long, 5cm radius // Joint connector const connectorVisual = new Visual (); connectorVisual . geometry = new SphereGeometry ( 0.08 ); // 8cm radius sphere connectorVisual . origin = new BABYLON . Vector3 ( 0 , 0 , 0.25 ); // At end of arm armLink . visuals . push ( mainVisual ); armLink . visuals . push ( connectorVisual ); armLink . create ( scene , materialMap );","title":"Link with Multiple Visuals"},{"location":"api/link.html#link-with-collision-geometry","text":"const chassisLink = new Link (); chassisLink . name = \"chassis\" ; // Visual geometry (detailed mesh) const visual = new Visual (); visual . geometry = new MeshGeometry ( \"chassis_detailed.dae\" ); chassisLink . visuals . push ( visual ); // Collision geometry (simplified box) const collision = new Visual (); collision . geometry = new BoxGeometry ( 2 , 1 , 0.5 ); // Simplified bounding box chassisLink . collisions . push ( collision ); chassisLink . create ( scene , materialMap );","title":"Link with Collision Geometry"},{"location":"api/link.html#visual-vs-collision-geometry","text":"","title":"Visual vs Collision Geometry"},{"location":"api/link.html#visual-geometries","text":"Purpose : What users see - detailed, textured models Rendering : Always visible by default Performance : Can be complex meshes with high polygon counts Materials : Use specified materials with textures and colors","title":"Visual Geometries"},{"location":"api/link.html#collision-geometries","text":"Purpose : Physics simulation and collision detection Rendering : Hidden by default (can be toggled for debugging) Performance : Should be simple shapes for fast collision detection Materials : Automatically use \"collision\" material (semi-transparent) // Visual: Detailed robot arm mesh const visual = new Visual (); visual . geometry = new MeshGeometry ( \"detailed_arm.dae\" ); // Collision: Simple cylinder approximation const collision = new Visual (); collision . geometry = new CylinderGeometry ( 0.5 , 0.08 , 0.08 ); link . visuals . push ( visual ); link . collisions . push ( collision );","title":"Collision Geometries"},{"location":"api/link.html#transform-hierarchy","text":"Links establish the structural hierarchy of the robot: // Link transforms are managed automatically // Parent joint -> Link transform -> Child visuals/collisions if ( link . transform ) { // Move entire link (affects all visuals and collisions) link . transform . position = new BABYLON . Vector3 ( 1 , 0 , 0 ); // All child visuals inherit this transformation console . log ( `Link has ${ link . visuals . length } visuals` ); console . log ( `Link has ${ link . collisions . length } collision shapes` ); }","title":"Transform Hierarchy"},{"location":"api/link.html#material-handling","text":"","title":"Material Handling"},{"location":"api/link.html#default-material","text":"// Link can have a default material link . material = materialMap . get ( \"aluminum\" ); // Individual visuals can override the link material visual . material = materialMap . get ( \"red_plastic\" );","title":"Default Material"},{"location":"api/link.html#material-priority","text":"Visual material : If specified, takes highest priority Link material : Used if visual has no specific material Default material : Used as fallback if neither is specified","title":"Material Priority"},{"location":"api/link.html#collision-materials","text":"// Collision geometries automatically use collision material // This provides semi-transparent rendering for debugging const collision = new Visual (); collision . geometry = new BoxGeometry ( 1 , 1 , 1 ); // collision.material is automatically set to \"collision\" material","title":"Collision Materials"},{"location":"api/link.html#accessing-link-components","text":"","title":"Accessing Link Components"},{"location":"api/link.html#iterating-through-visuals","text":"for ( const visual of link . visuals ) { console . log ( `Visual at: ${ visual . origin } ` ); if ( visual . geometry ) { console . log ( `Geometry type: ${ visual . geometry . constructor . name } ` ); } }","title":"Iterating Through Visuals"},{"location":"api/link.html#checking-link-properties","text":"// Get link bounding box let min = new BABYLON . Vector3 ( Infinity , Infinity , Infinity ); let max = new BABYLON . Vector3 ( - Infinity , - Infinity , - Infinity ); for ( const visual of link . visuals ) { if ( visual . mesh ) { const bounds = visual . mesh . getBoundingInfo (); BABYLON . Vector3 . MinimizeInPlace ( min , bounds . boundingBox . minimumWorld ); BABYLON . Vector3 . MaximizeInPlace ( max , bounds . boundingBox . maximumWorld ); } } const size = max . subtract ( min ); console . log ( `Link bounding box: ${ size . x } x ${ size . y } x ${ size . z } ` );","title":"Checking Link Properties"},{"location":"api/link.html#enablingdisabling-collision-visualization","text":"// Show collision geometry for debugging for ( const collision of link . collisions ) { collision . setEnabled ( true ); } // Hide collision geometry for ( const collision of link . collisions ) { collision . setEnabled ( false ); }","title":"Enabling/Disabling Collision Visualization"},{"location":"api/link.html#integration-with-robot","text":"Links are typically created as part of robot loading: // Links are populated from URDF const robot = urdf . loadRobot ( urdfDoc , scene , {}); // Access specific link const baseLink = robot . links . get ( \"base_link\" ); if ( baseLink ) { console . log ( `Base link has ${ baseLink . visuals . length } visual components` ); console . log ( `Base link has ${ baseLink . collisions . length } collision components` ); } // Iterate through all links for ( const [ name , link ] of robot . links ) { console . log ( `Link: ${ name } ` ); console . log ( ` Visuals: ${ link . visuals . length } ` ); console . log ( ` Collisions: ${ link . collisions . length } ` ); }","title":"Integration with Robot"},{"location":"api/link.html#common-link-types","text":"","title":"Common Link Types"},{"location":"api/link.html#base-links","text":"// Main chassis or body of the robot const baseLink = new Link (); baseLink . name = \"base_link\" ; // Usually contains the main structural geometry","title":"Base Links"},{"location":"api/link.html#arm-links","text":"// Robot arm segments const upperArm = new Link (); upperArm . name = \"upper_arm\" ; const forearm = new Link (); forearm . name = \"forearm\" ;","title":"Arm Links"},{"location":"api/link.html#sensor-links","text":"// Camera, LiDAR, or other sensor mounts const cameraLink = new Link (); cameraLink . name = \"camera_link\" ; // Often contain simple geometry for sensor housings","title":"Sensor Links"},{"location":"api/link.html#performance-considerations","text":"Visual Complexity : Detailed visuals are rendered, so balance quality vs performance Collision Simplicity : Keep collision geometry simple for fast physics simulation Material Sharing : Reuse materials across links to reduce memory usage Proper Disposal : Always dispose links to prevent memory leaks","title":"Performance Considerations"},{"location":"api/link.html#error-handling","text":"The Link class provides robust error handling: - Handles missing materials gracefully with fallbacks - Safely manages transform hierarchy - Properly disposes of all child resources - Logs warnings for malformed geometry","title":"Error Handling"},{"location":"api/material.html","text":"Material API The Material class defines visual properties for robot surfaces, including colors and textures. Constructor const material = new Material (); Creates a new Material instance with default values. Properties Public Properties Property Type Description name string Material identifier (default: \"default\") filename string Path to texture image file color BABYLON.Color4 \\| undefined RGBA color values material BABYLON.Material \\| undefined The Babylon.js material instance Methods Lifecycle Methods create(scene: BABYLON.Scene): void Creates the Babylon.js material in the scene based on the material properties. Parameters: - scene : BABYLON.Scene - The Babylon.js scene Behavior: - Creates a StandardMaterial with the material name - If filename is specified, creates a texture-based material - If color is specified, creates a color-based material - Sets material properties like alpha and backface culling Example: material . create ( scene ); dispose(): void Cleans up the Babylon.js material resources. Example: material . dispose (); Utility Methods isReference(): boolean Determines if this material is a reference to another material by name. Returns: boolean - true if this is a reference (no filename or color defined) Example: if ( material . isReference ()) { console . log ( \"This material references another material by name\" ); } Material Types Color-Based Materials const redMaterial = new Material (); redMaterial . name = \"red_plastic\" ; redMaterial . color = new BABYLON . Color4 ( 1 , 0 , 0 , 1 ); // Red, fully opaque redMaterial . create ( scene ); Texture-Based Materials const textureMaterial = new Material (); textureMaterial . name = \"wood_texture\" ; textureMaterial . filename = \"textures/wood.png\" ; textureMaterial . create ( scene ); Reference Materials // Reference an existing material by name const materialRef = new Material (); materialRef . name = \"existing_material\" ; // Must exist in material map // No color or filename - this is a reference console . log ( materialRef . isReference ()); // true CollisionMaterial Class A specialized material for collision geometry visualization. Constructor const collisionMat = new CollisionMaterial (); Properties Name : Always \"collision\" Color : Semi-transparent red (alpha = 0.25) Purpose : Visual debugging of collision shapes Usage const collisionMaterial = new CollisionMaterial (); collisionMaterial . create ( scene ); // Applied automatically to collision visuals collision . material = materialMap . get ( \"collision\" ); Usage Examples Creating Colored Materials // Solid colors const blueMaterial = new Material (); blueMaterial . name = \"blue_metal\" ; blueMaterial . color = new BABYLON . Color4 ( 0 , 0 , 1 , 1 ); // Blue // Semi-transparent const glassMaterial = new Material (); glassMaterial . name = \"glass\" ; glassMaterial . color = new BABYLON . Color4 ( 0.8 , 0.8 , 1 , 0.3 ); // Light blue, 30% opacity // Grayscale const grayMaterial = new Material (); grayMaterial . name = \"aluminum\" ; grayMaterial . color = new BABYLON . Color4 ( 0.7 , 0.7 , 0.7 , 1 ); // 70% gray Creating Textured Materials // Image texture const logoMaterial = new Material (); logoMaterial . name = \"company_logo\" ; logoMaterial . filename = \"textures/logo.png\" ; // Material with transparency support const decalMaterial = new Material (); decalMaterial . name = \"warning_decal\" ; decalMaterial . filename = \"textures/warning.png\" ; // PNG with alpha channel Material References in URDF Context // In robot materials map const materialMap = new Map < string , Material > (); // Define base materials const redPlastic = new Material (); redPlastic . name = \"red_plastic\" ; redPlastic . color = new BABYLON . Color4 ( 1 , 0 , 0 , 1 ); materialMap . set ( \"red_plastic\" , redPlastic ); // Use reference in visual const visual = new Visual (); const materialRef = new Material (); materialRef . name = \"red_plastic\" ; // References the material above visual . material = materialRef ; Color Format BABYLON.Color4 Components const color = new BABYLON . Color4 ( r , g , b , a ); r : Red component (0.0 to 1.0) g : Green component (0.0 to 1.0) b : Blue component (0.0 to 1.0) a : Alpha/opacity (0.0 = transparent, 1.0 = opaque) Common Colors // Primary colors const red = new BABYLON . Color4 ( 1 , 0 , 0 , 1 ); const green = new BABYLON . Color4 ( 0 , 1 , 0 , 1 ); const blue = new BABYLON . Color4 ( 0 , 0 , 1 , 1 ); // Neutral colors const white = new BABYLON . Color4 ( 1 , 1 , 1 , 1 ); const black = new BABYLON . Color4 ( 0 , 0 , 0 , 1 ); const gray = new BABYLON . Color4 ( 0.5 , 0.5 , 0.5 , 1 ); // Material-like colors const gold = new BABYLON . Color4 ( 1 , 0.84 , 0 , 1 ); const silver = new BABYLON . Color4 ( 0.75 , 0.75 , 0.75 , 1 ); const copper = new BABYLON . Color4 ( 0.72 , 0.45 , 0.20 , 1 ); Texture Support Supported Formats PNG : Best for images with transparency JPG/JPEG : Good for photographs and solid textures GIF : Basic support BMP : Basic support Texture Properties // Babylon.js automatically handles: // - Texture loading and caching // - Alpha channel support // - Texture filtering and mipmapping // - UV coordinate mapping Material Properties Babylon.js StandardMaterial Properties When created, materials have these characteristics: // Applied automatically: material . backFaceCulling = false ; // Render both sides material . diffuseColor = color ; // Base color material . alpha = color . a ; // Transparency material . diffuseTexture = texture ; // If filename specified Advanced Properties For custom material properties, access the Babylon.js material: material . create ( scene ); if ( material . material instanceof BABYLON . StandardMaterial ) { material . material . specularColor = new BABYLON . Color3 ( 1 , 1 , 1 ); material . material . specularPower = 32 ; material . material . emissiveColor = new BABYLON . Color3 ( 0.1 , 0.1 , 0.1 ); } Integration with Robot Default Materials Every Robot gets these materials automatically: // Default gray material const defaultMat = new Material (); defaultMat . name = \"default\" ; defaultMat . color = new BABYLON . Color4 ( 0.5 , 0.5 , 0.5 , 1 ); // Collision visualization material const collisionMat = new CollisionMaterial (); URDF Material Loading // Materials are typically loaded from URDF files // and stored in the robot's material map for ( const [ name , material ] of robot . materials ) { material . create ( scene ); console . log ( `Created material: ${ name } ` ); } Performance Considerations Material Sharing // Reuse materials across multiple objects const sharedMaterial = materialMap . get ( \"aluminum\" ); visual1 . material = sharedMaterial ; visual2 . material = sharedMaterial ; // Same material instance Texture Optimization Use appropriate texture sizes (512x512, 1024x1024) Compress textures when possible Avoid excessive transparency for performance Memory Management // Always dispose materials when done material . dispose (); // Reference materials are disposed by the Robot if ( ! material . isReference ()) { material . dispose (); } Error Handling The Material class provides robust error handling: - Handles missing texture files gracefully - Provides fallback to color-based materials - Safe disposal of Babylon.js resources - Logs warnings for invalid material properties","title":"Material"},{"location":"api/material.html#material-api","text":"The Material class defines visual properties for robot surfaces, including colors and textures.","title":"Material API"},{"location":"api/material.html#constructor","text":"const material = new Material (); Creates a new Material instance with default values.","title":"Constructor"},{"location":"api/material.html#properties","text":"","title":"Properties"},{"location":"api/material.html#public-properties","text":"Property Type Description name string Material identifier (default: \"default\") filename string Path to texture image file color BABYLON.Color4 \\| undefined RGBA color values material BABYLON.Material \\| undefined The Babylon.js material instance","title":"Public Properties"},{"location":"api/material.html#methods","text":"","title":"Methods"},{"location":"api/material.html#lifecycle-methods","text":"","title":"Lifecycle Methods"},{"location":"api/material.html#createscene-babylonscene-void","text":"Creates the Babylon.js material in the scene based on the material properties. Parameters: - scene : BABYLON.Scene - The Babylon.js scene Behavior: - Creates a StandardMaterial with the material name - If filename is specified, creates a texture-based material - If color is specified, creates a color-based material - Sets material properties like alpha and backface culling Example: material . create ( scene );","title":"create(scene: BABYLON.Scene): void"},{"location":"api/material.html#dispose-void","text":"Cleans up the Babylon.js material resources. Example: material . dispose ();","title":"dispose(): void"},{"location":"api/material.html#utility-methods","text":"","title":"Utility Methods"},{"location":"api/material.html#isreference-boolean","text":"Determines if this material is a reference to another material by name. Returns: boolean - true if this is a reference (no filename or color defined) Example: if ( material . isReference ()) { console . log ( \"This material references another material by name\" ); }","title":"isReference(): boolean"},{"location":"api/material.html#material-types","text":"","title":"Material Types"},{"location":"api/material.html#color-based-materials","text":"const redMaterial = new Material (); redMaterial . name = \"red_plastic\" ; redMaterial . color = new BABYLON . Color4 ( 1 , 0 , 0 , 1 ); // Red, fully opaque redMaterial . create ( scene );","title":"Color-Based Materials"},{"location":"api/material.html#texture-based-materials","text":"const textureMaterial = new Material (); textureMaterial . name = \"wood_texture\" ; textureMaterial . filename = \"textures/wood.png\" ; textureMaterial . create ( scene );","title":"Texture-Based Materials"},{"location":"api/material.html#reference-materials","text":"// Reference an existing material by name const materialRef = new Material (); materialRef . name = \"existing_material\" ; // Must exist in material map // No color or filename - this is a reference console . log ( materialRef . isReference ()); // true","title":"Reference Materials"},{"location":"api/material.html#collisionmaterial-class","text":"A specialized material for collision geometry visualization.","title":"CollisionMaterial Class"},{"location":"api/material.html#constructor_1","text":"const collisionMat = new CollisionMaterial ();","title":"Constructor"},{"location":"api/material.html#properties_1","text":"Name : Always \"collision\" Color : Semi-transparent red (alpha = 0.25) Purpose : Visual debugging of collision shapes","title":"Properties"},{"location":"api/material.html#usage","text":"const collisionMaterial = new CollisionMaterial (); collisionMaterial . create ( scene ); // Applied automatically to collision visuals collision . material = materialMap . get ( \"collision\" );","title":"Usage"},{"location":"api/material.html#usage-examples","text":"","title":"Usage Examples"},{"location":"api/material.html#creating-colored-materials","text":"// Solid colors const blueMaterial = new Material (); blueMaterial . name = \"blue_metal\" ; blueMaterial . color = new BABYLON . Color4 ( 0 , 0 , 1 , 1 ); // Blue // Semi-transparent const glassMaterial = new Material (); glassMaterial . name = \"glass\" ; glassMaterial . color = new BABYLON . Color4 ( 0.8 , 0.8 , 1 , 0.3 ); // Light blue, 30% opacity // Grayscale const grayMaterial = new Material (); grayMaterial . name = \"aluminum\" ; grayMaterial . color = new BABYLON . Color4 ( 0.7 , 0.7 , 0.7 , 1 ); // 70% gray","title":"Creating Colored Materials"},{"location":"api/material.html#creating-textured-materials","text":"// Image texture const logoMaterial = new Material (); logoMaterial . name = \"company_logo\" ; logoMaterial . filename = \"textures/logo.png\" ; // Material with transparency support const decalMaterial = new Material (); decalMaterial . name = \"warning_decal\" ; decalMaterial . filename = \"textures/warning.png\" ; // PNG with alpha channel","title":"Creating Textured Materials"},{"location":"api/material.html#material-references-in-urdf-context","text":"// In robot materials map const materialMap = new Map < string , Material > (); // Define base materials const redPlastic = new Material (); redPlastic . name = \"red_plastic\" ; redPlastic . color = new BABYLON . Color4 ( 1 , 0 , 0 , 1 ); materialMap . set ( \"red_plastic\" , redPlastic ); // Use reference in visual const visual = new Visual (); const materialRef = new Material (); materialRef . name = \"red_plastic\" ; // References the material above visual . material = materialRef ;","title":"Material References in URDF Context"},{"location":"api/material.html#color-format","text":"","title":"Color Format"},{"location":"api/material.html#babyloncolor4-components","text":"const color = new BABYLON . Color4 ( r , g , b , a ); r : Red component (0.0 to 1.0) g : Green component (0.0 to 1.0) b : Blue component (0.0 to 1.0) a : Alpha/opacity (0.0 = transparent, 1.0 = opaque)","title":"BABYLON.Color4 Components"},{"location":"api/material.html#common-colors","text":"// Primary colors const red = new BABYLON . Color4 ( 1 , 0 , 0 , 1 ); const green = new BABYLON . Color4 ( 0 , 1 , 0 , 1 ); const blue = new BABYLON . Color4 ( 0 , 0 , 1 , 1 ); // Neutral colors const white = new BABYLON . Color4 ( 1 , 1 , 1 , 1 ); const black = new BABYLON . Color4 ( 0 , 0 , 0 , 1 ); const gray = new BABYLON . Color4 ( 0.5 , 0.5 , 0.5 , 1 ); // Material-like colors const gold = new BABYLON . Color4 ( 1 , 0.84 , 0 , 1 ); const silver = new BABYLON . Color4 ( 0.75 , 0.75 , 0.75 , 1 ); const copper = new BABYLON . Color4 ( 0.72 , 0.45 , 0.20 , 1 );","title":"Common Colors"},{"location":"api/material.html#texture-support","text":"","title":"Texture Support"},{"location":"api/material.html#supported-formats","text":"PNG : Best for images with transparency JPG/JPEG : Good for photographs and solid textures GIF : Basic support BMP : Basic support","title":"Supported Formats"},{"location":"api/material.html#texture-properties","text":"// Babylon.js automatically handles: // - Texture loading and caching // - Alpha channel support // - Texture filtering and mipmapping // - UV coordinate mapping","title":"Texture Properties"},{"location":"api/material.html#material-properties","text":"","title":"Material Properties"},{"location":"api/material.html#babylonjs-standardmaterial-properties","text":"When created, materials have these characteristics: // Applied automatically: material . backFaceCulling = false ; // Render both sides material . diffuseColor = color ; // Base color material . alpha = color . a ; // Transparency material . diffuseTexture = texture ; // If filename specified","title":"Babylon.js StandardMaterial Properties"},{"location":"api/material.html#advanced-properties","text":"For custom material properties, access the Babylon.js material: material . create ( scene ); if ( material . material instanceof BABYLON . StandardMaterial ) { material . material . specularColor = new BABYLON . Color3 ( 1 , 1 , 1 ); material . material . specularPower = 32 ; material . material . emissiveColor = new BABYLON . Color3 ( 0.1 , 0.1 , 0.1 ); }","title":"Advanced Properties"},{"location":"api/material.html#integration-with-robot","text":"","title":"Integration with Robot"},{"location":"api/material.html#default-materials","text":"Every Robot gets these materials automatically: // Default gray material const defaultMat = new Material (); defaultMat . name = \"default\" ; defaultMat . color = new BABYLON . Color4 ( 0.5 , 0.5 , 0.5 , 1 ); // Collision visualization material const collisionMat = new CollisionMaterial ();","title":"Default Materials"},{"location":"api/material.html#urdf-material-loading","text":"// Materials are typically loaded from URDF files // and stored in the robot's material map for ( const [ name , material ] of robot . materials ) { material . create ( scene ); console . log ( `Created material: ${ name } ` ); }","title":"URDF Material Loading"},{"location":"api/material.html#performance-considerations","text":"","title":"Performance Considerations"},{"location":"api/material.html#material-sharing","text":"// Reuse materials across multiple objects const sharedMaterial = materialMap . get ( \"aluminum\" ); visual1 . material = sharedMaterial ; visual2 . material = sharedMaterial ; // Same material instance","title":"Material Sharing"},{"location":"api/material.html#texture-optimization","text":"Use appropriate texture sizes (512x512, 1024x1024) Compress textures when possible Avoid excessive transparency for performance","title":"Texture Optimization"},{"location":"api/material.html#memory-management","text":"// Always dispose materials when done material . dispose (); // Reference materials are disposed by the Robot if ( ! material . isReference ()) { material . dispose (); }","title":"Memory Management"},{"location":"api/material.html#error-handling","text":"The Material class provides robust error handling: - Handles missing texture files gracefully - Provides fallback to color-based materials - Safe disposal of Babylon.js resources - Logs warnings for invalid material properties","title":"Error Handling"},{"location":"api/robot-scene.html","text":"RobotScene API The RobotScene class is the main controller for robot visualization and interaction. It manages the 3D scene, camera, UI, and all robot components. Constructor const robotScene = new RobotScene (); Creates a new RobotScene instance. No parameters required. Properties Public Properties Property Type Description engine BABYLON.Engine \\| undefined The Babylon.js rendering engine scene BABYLON.Scene \\| undefined The main 3D scene currentURDF string \\| undefined The current URDF XML string currentRobot Robot \\| undefined The current robot instance UILayer GUI.AdvancedDynamicTexture \\| undefined The UI overlay layer ground BABYLON.GroundMesh \\| undefined The ground plane mesh camera BABYLON.ArcRotateCamera \\| undefined The scene camera readyToRender Boolean Whether the scene is ready for rendering Methods Scene Management createScene(canvas: HTMLCanvasElement): Promise<void> Initializes the 3D scene with the Babylon.js engine. Parameters: - canvas : HTMLCanvasElement - The HTML canvas element to render to Returns: Promise that resolves when scene creation is complete Example: const canvas = document . getElementById ( 'renderCanvas' ) as HTMLCanvasElement ; await robotScene . createScene ( canvas ); createUI(): void Creates the user interface elements including the hamburger menu and controls. Example: robotScene . createUI (); Robot Operations applyURDF(urdfText: string, vscode?: any): Promise<void> Loads and visualizes a robot from URDF XML content. Parameters: - urdfText : string - The URDF XML content as a string - vscode : any (optional) - VS Code context for debugging Returns: Promise that resolves when URDF loading is complete Example: const urdfContent = await fetch ( 'robot.urdf' ). then ( r => r . text ()); await robotScene . applyURDF ( urdfContent ); Camera Control resetCamera(): void Resets the camera to the default position and target based on the robot's bounding box. Example: robotScene . resetCamera (); setCameraRadius(radius: number): void Sets the camera distance from its target. Parameters: - radius : number - The camera distance from its target Example: robotScene . setCameraRadius ( 5.0 ); Visual Configuration setBackgroundColor(hexColor: string): void Sets the scene background color using a hex color string. Parameters: - hexColor : string - Hex color string (e.g., \"#FF0000\" or \"FF0000\") Example: robotScene . setBackgroundColor ( \"#1a1a1a\" ); setGridProperties(options: object): void Sets the grid material properties for customizing the ground grid appearance. Parameters: - options : object - Grid configuration options - lineColor?: string - Hex color for grid lines - mainColor?: string - Hex color for grid background - minorOpacity?: number - Opacity of minor grid lines (0-1) - gridRatio?: number - Ratio between major and minor grid lines - majorUnitFrequency?: number - Frequency of major grid lines Example: robotScene . setGridProperties ({ lineColor : \"#00FF00\" , mainColor : \"#004400\" , minorOpacity : 0.3 , gridRatio : 1.0 , majorUnitFrequency : 10 }); setMirrorProperties(options: object): void Sets mirror reflection properties for customizing the ground mirror appearance. Parameters: - options : object - Mirror configuration options - reflectionLevel?: number - Strength of reflections (0-1) - alpha?: number - Mirror transparency (0-1) - tintColor?: string - Hex color for mirror tinting - blurKernel?: number - Blur amount for softer reflections (0+) - roughness?: number - Material roughness (0-1) - enabled?: boolean - Enable/disable mirror entirely Example: robotScene . setMirrorProperties ({ reflectionLevel : 0.3 , alpha : 0.4 , tintColor : \"#001100\" , blurKernel : 16 , roughness : 0.6 , enabled : true }); setVisualConfig(config: object): void Sets all visual properties at once for convenient bulk configuration. Parameters: - config : object - Complete visual configuration - cameraRadius?: number - Camera distance from target - backgroundColor?: string - Scene background color (hex) - gridLineColor?: string - Grid line color (hex) - gridMainColor?: string - Grid background color (hex) - gridMinorOpacity?: number - Minor grid line opacity (0-1) - gridRatio?: number - Grid line ratio - majorUnitFrequency?: number - Major grid line frequency - mirrorReflectionLevel?: number - Mirror reflection strength (0-1) - mirrorAlpha?: number - Mirror transparency (0-1) - mirrorTintColor?: string - Mirror tint color (hex) - mirrorBlurKernel?: number - Mirror blur amount (0+) - mirrorRoughness?: number - Mirror roughness (0-1) - mirrorEnabled?: boolean - Enable/disable mirror Returns: void Example: robotScene . setVisualConfig ({ cameraRadius : 8.0 , backgroundColor : \"#2a2a2a\" , gridLineColor : \"#00AA00\" , gridMainColor : \"#003300\" , gridMinorOpacity : 0.25 , gridRatio : 1.2 , majorUnitFrequency : 8 , mirrorReflectionLevel : 0.4 , mirrorAlpha : 0.6 , mirrorTintColor : \"#002200\" , mirrorBlurKernel : 20 , mirrorRoughness : 0.3 , mirrorEnabled : true }); Screenshot and Export takeScreenshot(width?: number, height?: number): Promise<string> Captures a screenshot of the current scene. Parameters: - width : number (optional) - Screenshot width in pixels (default: canvas width) - height : number (optional) - Screenshot height in pixels (default: canvas height) Returns: Promise that resolves to a base64 encoded PNG image string Example: const screenshot = await robotScene . takeScreenshot ( 1920 , 1080 ); // screenshot is a base64 string: \"data:image/png;base64,iVBORw0KGgoAAAA...\" Interactive Features toggleAxisOnRobot(jointOrLink: boolean, scene: BABYLON.Scene, layer: BABYLON.UtilityLayerRenderer): void Toggles position gizmos on joints or links for interactive manipulation. Parameters: - jointOrLink : boolean - true for joints, false for links - scene : BABYLON.Scene - The Babylon.js scene - layer : BABYLON.UtilityLayerRenderer - The utility layer for gizmos toggleAxisRotationOnRobot(jointOrLink: boolean, ui: GUI.AdvancedDynamicTexture, scene: BABYLON.Scene, layer: BABYLON.UtilityLayerRenderer): void Toggles rotation gizmos on joints or links for interactive manipulation. Parameters: - jointOrLink : boolean - true for joints, false for links - ui : GUI.AdvancedDynamicTexture - The UI layer - scene : BABYLON.Scene - The Babylon.js scene - layer : BABYLON.UtilityLayerRenderer - The utility layer for gizmos Utility Methods clearStatus(): void Clears the status text display. clearAxisGizmos(): void Removes all position gizmos from the scene. clearRotationGizmos(): void Removes all rotation gizmos from the scene. clearJointExerciseGizmos(): void Removes joint exercise gizmos (advanced joint manipulation tools). Events and Interactions The RobotScene class handles various user interactions: Mouse hover : Highlights joints and shows information Click selection : Selects visual elements for manipulation Gizmo interaction : Real-time position and rotation updates Menu interactions : Hamburger menu with feature toggles UI Features The RobotScene provides a comprehensive UI system including: Hamburger Menu : Collapsible menu with organized controls Grid Controls : Toggle grid display with 10cm and 1m increments Axis Visualization : Show/hide coordinate axes on joints and links Joint Exercise : Interactive joint manipulation tools Camera Controls : Reset and frame robot functionality Screenshot Capture : Export current view as PNG Grid System The scene includes a comprehensive grid system: Base Grid : Large grid plane for reference Measurement Labels : X, Y, Z axis labels with distance markers Units : Configurable 10cm and 1m increments Color Coding : Red (X), Green (Y), Blue (Z) axis labels Example Usage import { RobotScene } from '@ranchhandrobotics/babylon_ros' ; // Create and initialize scene const robotScene = new RobotScene (); const canvas = document . getElementById ( 'renderCanvas' ) as HTMLCanvasElement ; await robotScene . createScene ( canvas ); robotScene . createUI (); // Load a robot const urdfContent = await fetch ( 'path/to/robot.urdf' ). then ( r => r . text ()); await robotScene . applyURDF ( urdfContent ); // Configure visual appearance using the new API robotScene . setVisualConfig ({ cameraRadius : 6.0 , backgroundColor : \"#1e1e1e\" , gridLineColor : \"#00AA00\" , gridMainColor : \"#002200\" , gridMinorOpacity : 0.3 , gridRatio : 1.0 , majorUnitFrequency : 10 , mirrorReflectionLevel : 0.3 , mirrorAlpha : 0.5 , mirrorTintColor : \"#001100\" , mirrorBlurKernel : 16 , mirrorEnabled : true }); // Or set properties individually robotScene . setBackgroundColor ( \"#2a2a2a\" ); robotScene . setCameraRadius ( 8.0 ); robotScene . setGridProperties ({ lineColor : \"#FF6600\" , mainColor : \"#330000\" , minorOpacity : 0.4 }); robotScene . setMirrorProperties ({ reflectionLevel : 0.2 , alpha : 0.3 , tintColor : \"#001122\" , blurKernel : 24 , roughness : 0.4 }); // Reset camera to frame the robot robotScene . resetCamera (); // Take a screenshot const screenshot = await robotScene . takeScreenshot ( 1920 , 1080 ); Migration from Direct Property Access If you were previously accessing properties directly, you can now use the new API methods: // OLD WAY (not recommended) currentRobotScene . camera . radius = message . cameraRadius ; currentRobotScene . scene . clearColor = BABYLON . Color4 . FromHexString ( message . backgroundColor ); let gm = currentRobotScene . ground . material as Materials . GridMaterial ; gm . lineColor = BABYLON . Color3 . FromHexString ( message . gridMainColor ); gm . mainColor = BABYLON . Color3 . FromHexString ( message . gridLineColor ); // NEW WAY (recommended) currentRobotScene . setVisualConfig ({ cameraRadius : message.cameraRadius , backgroundColor : message.backgroundColor , gridLineColor : message.gridMainColor , gridMainColor : message.gridLineColor , gridMinorOpacity : parseFloat ( message . gridMinorOpacity ), gridRatio : parseFloat ( message . gridRatio ), majorUnitFrequency : parseFloat ( message . majorUnitFrequency ) }); Performance Considerations The scene automatically manages mesh loading and rendering optimization Large robots with many meshes are handled asynchronously The UI system uses efficient event handling to minimize performance impact Screenshot capture is GPU-accelerated when available Browser Compatibility RobotScene requires: - WebGL 2.0 support - ES6+ JavaScript features - Modern browser (Chrome 80+, Firefox 75+, Safari 13+, Edge 80+)","title":"RobotScene"},{"location":"api/robot-scene.html#robotscene-api","text":"The RobotScene class is the main controller for robot visualization and interaction. It manages the 3D scene, camera, UI, and all robot components.","title":"RobotScene API"},{"location":"api/robot-scene.html#constructor","text":"const robotScene = new RobotScene (); Creates a new RobotScene instance. No parameters required.","title":"Constructor"},{"location":"api/robot-scene.html#properties","text":"","title":"Properties"},{"location":"api/robot-scene.html#public-properties","text":"Property Type Description engine BABYLON.Engine \\| undefined The Babylon.js rendering engine scene BABYLON.Scene \\| undefined The main 3D scene currentURDF string \\| undefined The current URDF XML string currentRobot Robot \\| undefined The current robot instance UILayer GUI.AdvancedDynamicTexture \\| undefined The UI overlay layer ground BABYLON.GroundMesh \\| undefined The ground plane mesh camera BABYLON.ArcRotateCamera \\| undefined The scene camera readyToRender Boolean Whether the scene is ready for rendering","title":"Public Properties"},{"location":"api/robot-scene.html#methods","text":"","title":"Methods"},{"location":"api/robot-scene.html#scene-management","text":"","title":"Scene Management"},{"location":"api/robot-scene.html#createscenecanvas-htmlcanvaselement-promisevoid","text":"Initializes the 3D scene with the Babylon.js engine. Parameters: - canvas : HTMLCanvasElement - The HTML canvas element to render to Returns: Promise that resolves when scene creation is complete Example: const canvas = document . getElementById ( 'renderCanvas' ) as HTMLCanvasElement ; await robotScene . createScene ( canvas );","title":"createScene(canvas: HTMLCanvasElement): Promise&lt;void&gt;"},{"location":"api/robot-scene.html#createui-void","text":"Creates the user interface elements including the hamburger menu and controls. Example: robotScene . createUI ();","title":"createUI(): void"},{"location":"api/robot-scene.html#robot-operations","text":"","title":"Robot Operations"},{"location":"api/robot-scene.html#applyurdfurdftext-string-vscode-any-promisevoid","text":"Loads and visualizes a robot from URDF XML content. Parameters: - urdfText : string - The URDF XML content as a string - vscode : any (optional) - VS Code context for debugging Returns: Promise that resolves when URDF loading is complete Example: const urdfContent = await fetch ( 'robot.urdf' ). then ( r => r . text ()); await robotScene . applyURDF ( urdfContent );","title":"applyURDF(urdfText: string, vscode?: any): Promise&lt;void&gt;"},{"location":"api/robot-scene.html#camera-control","text":"","title":"Camera Control"},{"location":"api/robot-scene.html#resetcamera-void","text":"Resets the camera to the default position and target based on the robot's bounding box. Example: robotScene . resetCamera ();","title":"resetCamera(): void"},{"location":"api/robot-scene.html#setcameraradiusradius-number-void","text":"Sets the camera distance from its target. Parameters: - radius : number - The camera distance from its target Example: robotScene . setCameraRadius ( 5.0 );","title":"setCameraRadius(radius: number): void"},{"location":"api/robot-scene.html#visual-configuration","text":"","title":"Visual Configuration"},{"location":"api/robot-scene.html#setbackgroundcolorhexcolor-string-void","text":"Sets the scene background color using a hex color string. Parameters: - hexColor : string - Hex color string (e.g., \"#FF0000\" or \"FF0000\") Example: robotScene . setBackgroundColor ( \"#1a1a1a\" );","title":"setBackgroundColor(hexColor: string): void"},{"location":"api/robot-scene.html#setgridpropertiesoptions-object-void","text":"Sets the grid material properties for customizing the ground grid appearance. Parameters: - options : object - Grid configuration options - lineColor?: string - Hex color for grid lines - mainColor?: string - Hex color for grid background - minorOpacity?: number - Opacity of minor grid lines (0-1) - gridRatio?: number - Ratio between major and minor grid lines - majorUnitFrequency?: number - Frequency of major grid lines Example: robotScene . setGridProperties ({ lineColor : \"#00FF00\" , mainColor : \"#004400\" , minorOpacity : 0.3 , gridRatio : 1.0 , majorUnitFrequency : 10 });","title":"setGridProperties(options: object): void"},{"location":"api/robot-scene.html#setmirrorpropertiesoptions-object-void","text":"Sets mirror reflection properties for customizing the ground mirror appearance. Parameters: - options : object - Mirror configuration options - reflectionLevel?: number - Strength of reflections (0-1) - alpha?: number - Mirror transparency (0-1) - tintColor?: string - Hex color for mirror tinting - blurKernel?: number - Blur amount for softer reflections (0+) - roughness?: number - Material roughness (0-1) - enabled?: boolean - Enable/disable mirror entirely Example: robotScene . setMirrorProperties ({ reflectionLevel : 0.3 , alpha : 0.4 , tintColor : \"#001100\" , blurKernel : 16 , roughness : 0.6 , enabled : true });","title":"setMirrorProperties(options: object): void"},{"location":"api/robot-scene.html#setvisualconfigconfig-object-void","text":"Sets all visual properties at once for convenient bulk configuration. Parameters: - config : object - Complete visual configuration - cameraRadius?: number - Camera distance from target - backgroundColor?: string - Scene background color (hex) - gridLineColor?: string - Grid line color (hex) - gridMainColor?: string - Grid background color (hex) - gridMinorOpacity?: number - Minor grid line opacity (0-1) - gridRatio?: number - Grid line ratio - majorUnitFrequency?: number - Major grid line frequency - mirrorReflectionLevel?: number - Mirror reflection strength (0-1) - mirrorAlpha?: number - Mirror transparency (0-1) - mirrorTintColor?: string - Mirror tint color (hex) - mirrorBlurKernel?: number - Mirror blur amount (0+) - mirrorRoughness?: number - Mirror roughness (0-1) - mirrorEnabled?: boolean - Enable/disable mirror Returns: void Example: robotScene . setVisualConfig ({ cameraRadius : 8.0 , backgroundColor : \"#2a2a2a\" , gridLineColor : \"#00AA00\" , gridMainColor : \"#003300\" , gridMinorOpacity : 0.25 , gridRatio : 1.2 , majorUnitFrequency : 8 , mirrorReflectionLevel : 0.4 , mirrorAlpha : 0.6 , mirrorTintColor : \"#002200\" , mirrorBlurKernel : 20 , mirrorRoughness : 0.3 , mirrorEnabled : true });","title":"setVisualConfig(config: object): void"},{"location":"api/robot-scene.html#screenshot-and-export","text":"","title":"Screenshot and Export"},{"location":"api/robot-scene.html#takescreenshotwidth-number-height-number-promisestring","text":"Captures a screenshot of the current scene. Parameters: - width : number (optional) - Screenshot width in pixels (default: canvas width) - height : number (optional) - Screenshot height in pixels (default: canvas height) Returns: Promise that resolves to a base64 encoded PNG image string Example: const screenshot = await robotScene . takeScreenshot ( 1920 , 1080 ); // screenshot is a base64 string: \"data:image/png;base64,iVBORw0KGgoAAAA...\"","title":"takeScreenshot(width?: number, height?: number): Promise&lt;string&gt;"},{"location":"api/robot-scene.html#interactive-features","text":"","title":"Interactive Features"},{"location":"api/robot-scene.html#toggleaxisonrobotjointorlink-boolean-scene-babylonscene-layer-babylonutilitylayerrenderer-void","text":"Toggles position gizmos on joints or links for interactive manipulation. Parameters: - jointOrLink : boolean - true for joints, false for links - scene : BABYLON.Scene - The Babylon.js scene - layer : BABYLON.UtilityLayerRenderer - The utility layer for gizmos","title":"toggleAxisOnRobot(jointOrLink: boolean, scene: BABYLON.Scene, layer: BABYLON.UtilityLayerRenderer): void"},{"location":"api/robot-scene.html#toggleaxisrotationonrobotjointorlink-boolean-ui-guiadvanceddynamictexture-scene-babylonscene-layer-babylonutilitylayerrenderer-void","text":"Toggles rotation gizmos on joints or links for interactive manipulation. Parameters: - jointOrLink : boolean - true for joints, false for links - ui : GUI.AdvancedDynamicTexture - The UI layer - scene : BABYLON.Scene - The Babylon.js scene - layer : BABYLON.UtilityLayerRenderer - The utility layer for gizmos","title":"toggleAxisRotationOnRobot(jointOrLink: boolean, ui: GUI.AdvancedDynamicTexture, scene: BABYLON.Scene, layer: BABYLON.UtilityLayerRenderer): void"},{"location":"api/robot-scene.html#utility-methods","text":"","title":"Utility Methods"},{"location":"api/robot-scene.html#clearstatus-void","text":"Clears the status text display.","title":"clearStatus(): void"},{"location":"api/robot-scene.html#clearaxisgizmos-void","text":"Removes all position gizmos from the scene.","title":"clearAxisGizmos(): void"},{"location":"api/robot-scene.html#clearrotationgizmos-void","text":"Removes all rotation gizmos from the scene.","title":"clearRotationGizmos(): void"},{"location":"api/robot-scene.html#clearjointexercisegizmos-void","text":"Removes joint exercise gizmos (advanced joint manipulation tools).","title":"clearJointExerciseGizmos(): void"},{"location":"api/robot-scene.html#events-and-interactions","text":"The RobotScene class handles various user interactions: Mouse hover : Highlights joints and shows information Click selection : Selects visual elements for manipulation Gizmo interaction : Real-time position and rotation updates Menu interactions : Hamburger menu with feature toggles","title":"Events and Interactions"},{"location":"api/robot-scene.html#ui-features","text":"The RobotScene provides a comprehensive UI system including: Hamburger Menu : Collapsible menu with organized controls Grid Controls : Toggle grid display with 10cm and 1m increments Axis Visualization : Show/hide coordinate axes on joints and links Joint Exercise : Interactive joint manipulation tools Camera Controls : Reset and frame robot functionality Screenshot Capture : Export current view as PNG","title":"UI Features"},{"location":"api/robot-scene.html#grid-system","text":"The scene includes a comprehensive grid system: Base Grid : Large grid plane for reference Measurement Labels : X, Y, Z axis labels with distance markers Units : Configurable 10cm and 1m increments Color Coding : Red (X), Green (Y), Blue (Z) axis labels","title":"Grid System"},{"location":"api/robot-scene.html#example-usage","text":"import { RobotScene } from '@ranchhandrobotics/babylon_ros' ; // Create and initialize scene const robotScene = new RobotScene (); const canvas = document . getElementById ( 'renderCanvas' ) as HTMLCanvasElement ; await robotScene . createScene ( canvas ); robotScene . createUI (); // Load a robot const urdfContent = await fetch ( 'path/to/robot.urdf' ). then ( r => r . text ()); await robotScene . applyURDF ( urdfContent ); // Configure visual appearance using the new API robotScene . setVisualConfig ({ cameraRadius : 6.0 , backgroundColor : \"#1e1e1e\" , gridLineColor : \"#00AA00\" , gridMainColor : \"#002200\" , gridMinorOpacity : 0.3 , gridRatio : 1.0 , majorUnitFrequency : 10 , mirrorReflectionLevel : 0.3 , mirrorAlpha : 0.5 , mirrorTintColor : \"#001100\" , mirrorBlurKernel : 16 , mirrorEnabled : true }); // Or set properties individually robotScene . setBackgroundColor ( \"#2a2a2a\" ); robotScene . setCameraRadius ( 8.0 ); robotScene . setGridProperties ({ lineColor : \"#FF6600\" , mainColor : \"#330000\" , minorOpacity : 0.4 }); robotScene . setMirrorProperties ({ reflectionLevel : 0.2 , alpha : 0.3 , tintColor : \"#001122\" , blurKernel : 24 , roughness : 0.4 }); // Reset camera to frame the robot robotScene . resetCamera (); // Take a screenshot const screenshot = await robotScene . takeScreenshot ( 1920 , 1080 );","title":"Example Usage"},{"location":"api/robot-scene.html#migration-from-direct-property-access","text":"If you were previously accessing properties directly, you can now use the new API methods: // OLD WAY (not recommended) currentRobotScene . camera . radius = message . cameraRadius ; currentRobotScene . scene . clearColor = BABYLON . Color4 . FromHexString ( message . backgroundColor ); let gm = currentRobotScene . ground . material as Materials . GridMaterial ; gm . lineColor = BABYLON . Color3 . FromHexString ( message . gridMainColor ); gm . mainColor = BABYLON . Color3 . FromHexString ( message . gridLineColor ); // NEW WAY (recommended) currentRobotScene . setVisualConfig ({ cameraRadius : message.cameraRadius , backgroundColor : message.backgroundColor , gridLineColor : message.gridMainColor , gridMainColor : message.gridLineColor , gridMinorOpacity : parseFloat ( message . gridMinorOpacity ), gridRatio : parseFloat ( message . gridRatio ), majorUnitFrequency : parseFloat ( message . majorUnitFrequency ) });","title":"Migration from Direct Property Access"},{"location":"api/robot-scene.html#performance-considerations","text":"The scene automatically manages mesh loading and rendering optimization Large robots with many meshes are handled asynchronously The UI system uses efficient event handling to minimize performance impact Screenshot capture is GPU-accelerated when available","title":"Performance Considerations"},{"location":"api/robot-scene.html#browser-compatibility","text":"RobotScene requires: - WebGL 2.0 support - ES6+ JavaScript features - Modern browser (Chrome 80+, Firefox 75+, Safari 13+, Edge 80+)","title":"Browser Compatibility"},{"location":"api/robot.html","text":"Robot API The Robot class represents a complete robot model loaded from URDF, managing all links, joints, and materials. Constructor const robot = new Robot (); Creates a new Robot instance with default materials. Properties Public Properties Property Type Description name string The robot's name transform BABYLON.TransformNode \\| undefined Root transform node for the entire robot links Map<string, Link> Map of link names to Link objects joints Map<string, Joint> Map of joint names to Joint objects materials Map<string, Material> Map of material names to Material objects Methods Lifecycle Methods create(scene: BABYLON.Scene): void Initializes the robot in the 3D scene, creating all transforms, materials, links, and joints. Parameters: - scene : BABYLON.Scene - The Babylon.js scene to create the robot in Behavior: - Creates a root transform node with ROS to Babylon.js coordinate conversion - Initializes all materials in the scene - Creates all links with their visual and collision geometries - Creates all joints and establishes parent-child relationships - Handles orphaned transforms by parenting them to the root Example: const robot = new Robot (); robot . name = \"my_robot\" ; robot . create ( scene ); dispose(): void Cleans up all resources used by the robot, including meshes, materials, and transforms. Example: robot . dispose (); Default Materials Every Robot instance starts with two default materials: Default Material Name : \"default\" Color : Gray (0.5, 0.5, 0.5, 1.0) Usage : Applied to robot parts without specific material definitions Collision Material Name : \"collision\" Type : CollisionMaterial Usage : Applied to collision geometry (typically semi-transparent) Transform Hierarchy The Robot class establishes a proper transform hierarchy: Root Transform : The robot's main transform node with ROS coordinate conversion Joint Transforms : Each joint is parented to its parent link Link Transforms : Each child link is parented to its joint Orphaned Links : Any links without parents are automatically parented to the root Coordinate System Conversion The robot automatically converts from ROS coordinate system to Babylon.js: - ROS : X-forward, Y-left, Z-up - Babylon.js : X-right, Y-up, Z-forward - Conversion : Rotation of -90\u00b0 around X-axis Usage Examples Basic Robot Creation import { Robot } from '@ranchhandrobotics/babylon_ros' ; const robot = new Robot (); robot . name = \"my_robot\" ; // Create in scene robot . create ( scene ); // Later cleanup robot . dispose (); Accessing Robot Components // Access specific link const baseLink = robot . links . get ( \"base_link\" ); // Access specific joint const wheelJoint = robot . joints . get ( \"wheel_joint\" ); // Access material const redMaterial = robot . materials . get ( \"red_plastic\" ); // Iterate through all links for ( const [ name , link ] of robot . links ) { console . log ( `Link: ${ name } ` ); } // Iterate through all joints for ( const [ name , joint ] of robot . joints ) { console . log ( `Joint: ${ name } , Type: ${ joint . type } ` ); } Working with Robot Transform // Move entire robot if ( robot . transform ) { robot . transform . position = new BABYLON . Vector3 ( 1 , 0 , 0 ); robot . transform . rotation = new BABYLON . Vector3 ( 0 , Math . PI / 4 , 0 ); } // Get robot bounding box let min = new BABYLON . Vector3 ( Infinity , Infinity , Infinity ); let max = new BABYLON . Vector3 ( - Infinity , - Infinity , - Infinity ); for ( const [ name , link ] of robot . links ) { for ( const visual of link . visuals ) { if ( visual . mesh ) { const boundingInfo = visual . mesh . getBoundingInfo (); BABYLON . Vector3 . MinimizeInPlace ( min , boundingInfo . boundingBox . minimumWorld ); BABYLON . Vector3 . MaximizeInPlace ( max , boundingInfo . boundingBox . maximumWorld ); } } } Integration with URDF The Robot class is typically populated from URDF data: import * as urdf from './urdf' ; // Parse URDF and populate robot const urdfDoc = new DOMParser (). parseFromString ( urdfText , 'text/xml' ); const robot = urdf . loadRobot ( urdfDoc , scene , {}); // Returns populated Robot instance Common Base Links The Robot class handles various naming conventions for base links: - base_link : Standard mobile robot base - base_footprint : Common for wheeled robots like TurtleBot - world : Used by some manufacturers like Unitree Error Handling The Robot class provides robust error handling: - Handles missing parent/child relationships gracefully - Automatically parents orphaned transforms - Provides safe disposal of all resources - Logs warnings for malformed robot structures Performance Considerations Large robots with many links/joints are handled efficiently Transform hierarchy is optimized for rendering performance Material sharing reduces memory usage Proper disposal prevents memory leaks Thread Safety The Robot class is designed for single-threaded use in browser environments. All operations should be performed on the main thread.","title":"Robot"},{"location":"api/robot.html#robot-api","text":"The Robot class represents a complete robot model loaded from URDF, managing all links, joints, and materials.","title":"Robot API"},{"location":"api/robot.html#constructor","text":"const robot = new Robot (); Creates a new Robot instance with default materials.","title":"Constructor"},{"location":"api/robot.html#properties","text":"","title":"Properties"},{"location":"api/robot.html#public-properties","text":"Property Type Description name string The robot's name transform BABYLON.TransformNode \\| undefined Root transform node for the entire robot links Map<string, Link> Map of link names to Link objects joints Map<string, Joint> Map of joint names to Joint objects materials Map<string, Material> Map of material names to Material objects","title":"Public Properties"},{"location":"api/robot.html#methods","text":"","title":"Methods"},{"location":"api/robot.html#lifecycle-methods","text":"","title":"Lifecycle Methods"},{"location":"api/robot.html#createscene-babylonscene-void","text":"Initializes the robot in the 3D scene, creating all transforms, materials, links, and joints. Parameters: - scene : BABYLON.Scene - The Babylon.js scene to create the robot in Behavior: - Creates a root transform node with ROS to Babylon.js coordinate conversion - Initializes all materials in the scene - Creates all links with their visual and collision geometries - Creates all joints and establishes parent-child relationships - Handles orphaned transforms by parenting them to the root Example: const robot = new Robot (); robot . name = \"my_robot\" ; robot . create ( scene );","title":"create(scene: BABYLON.Scene): void"},{"location":"api/robot.html#dispose-void","text":"Cleans up all resources used by the robot, including meshes, materials, and transforms. Example: robot . dispose ();","title":"dispose(): void"},{"location":"api/robot.html#default-materials","text":"Every Robot instance starts with two default materials:","title":"Default Materials"},{"location":"api/robot.html#default-material","text":"Name : \"default\" Color : Gray (0.5, 0.5, 0.5, 1.0) Usage : Applied to robot parts without specific material definitions","title":"Default Material"},{"location":"api/robot.html#collision-material","text":"Name : \"collision\" Type : CollisionMaterial Usage : Applied to collision geometry (typically semi-transparent)","title":"Collision Material"},{"location":"api/robot.html#transform-hierarchy","text":"The Robot class establishes a proper transform hierarchy: Root Transform : The robot's main transform node with ROS coordinate conversion Joint Transforms : Each joint is parented to its parent link Link Transforms : Each child link is parented to its joint Orphaned Links : Any links without parents are automatically parented to the root","title":"Transform Hierarchy"},{"location":"api/robot.html#coordinate-system-conversion","text":"The robot automatically converts from ROS coordinate system to Babylon.js: - ROS : X-forward, Y-left, Z-up - Babylon.js : X-right, Y-up, Z-forward - Conversion : Rotation of -90\u00b0 around X-axis","title":"Coordinate System Conversion"},{"location":"api/robot.html#usage-examples","text":"","title":"Usage Examples"},{"location":"api/robot.html#basic-robot-creation","text":"import { Robot } from '@ranchhandrobotics/babylon_ros' ; const robot = new Robot (); robot . name = \"my_robot\" ; // Create in scene robot . create ( scene ); // Later cleanup robot . dispose ();","title":"Basic Robot Creation"},{"location":"api/robot.html#accessing-robot-components","text":"// Access specific link const baseLink = robot . links . get ( \"base_link\" ); // Access specific joint const wheelJoint = robot . joints . get ( \"wheel_joint\" ); // Access material const redMaterial = robot . materials . get ( \"red_plastic\" ); // Iterate through all links for ( const [ name , link ] of robot . links ) { console . log ( `Link: ${ name } ` ); } // Iterate through all joints for ( const [ name , joint ] of robot . joints ) { console . log ( `Joint: ${ name } , Type: ${ joint . type } ` ); }","title":"Accessing Robot Components"},{"location":"api/robot.html#working-with-robot-transform","text":"// Move entire robot if ( robot . transform ) { robot . transform . position = new BABYLON . Vector3 ( 1 , 0 , 0 ); robot . transform . rotation = new BABYLON . Vector3 ( 0 , Math . PI / 4 , 0 ); } // Get robot bounding box let min = new BABYLON . Vector3 ( Infinity , Infinity , Infinity ); let max = new BABYLON . Vector3 ( - Infinity , - Infinity , - Infinity ); for ( const [ name , link ] of robot . links ) { for ( const visual of link . visuals ) { if ( visual . mesh ) { const boundingInfo = visual . mesh . getBoundingInfo (); BABYLON . Vector3 . MinimizeInPlace ( min , boundingInfo . boundingBox . minimumWorld ); BABYLON . Vector3 . MaximizeInPlace ( max , boundingInfo . boundingBox . maximumWorld ); } } }","title":"Working with Robot Transform"},{"location":"api/robot.html#integration-with-urdf","text":"The Robot class is typically populated from URDF data: import * as urdf from './urdf' ; // Parse URDF and populate robot const urdfDoc = new DOMParser (). parseFromString ( urdfText , 'text/xml' ); const robot = urdf . loadRobot ( urdfDoc , scene , {}); // Returns populated Robot instance","title":"Integration with URDF"},{"location":"api/robot.html#common-base-links","text":"The Robot class handles various naming conventions for base links: - base_link : Standard mobile robot base - base_footprint : Common for wheeled robots like TurtleBot - world : Used by some manufacturers like Unitree","title":"Common Base Links"},{"location":"api/robot.html#error-handling","text":"The Robot class provides robust error handling: - Handles missing parent/child relationships gracefully - Automatically parents orphaned transforms - Provides safe disposal of all resources - Logs warnings for malformed robot structures","title":"Error Handling"},{"location":"api/robot.html#performance-considerations","text":"Large robots with many links/joints are handled efficiently Transform hierarchy is optimized for rendering performance Material sharing reduces memory usage Proper disposal prevents memory leaks","title":"Performance Considerations"},{"location":"api/robot.html#thread-safety","text":"The Robot class is designed for single-threaded use in browser environments. All operations should be performed on the main thread.","title":"Thread Safety"},{"location":"api/utilities.html","text":"Utilities API Helper functions for parsing and transforming data between different coordinate systems and formats. Parsing Functions parseVector(vec: string): BABYLON.Vector3 Parses a space-separated string into a Babylon.js Vector3. Parameters: - vec : string - Space-separated coordinates (e.g., \"1.5 0.0 0.3\") Returns: BABYLON.Vector3 - Parsed vector Throws: Error if string doesn't contain exactly 3 values Example: import { parseVector } from '@ranchhandrobotics/babylon_ros' ; // Parse position from URDF const positionStr = \"1.0 0.5 0.25\" ; const position = parseVector ( positionStr ); console . log ( position ); // Vector3(1.0, 0.5, 0.25) // Use in transform joint . origin = parseVector ( \"0 0 0.1\" ); parseRPY(rpy: string): BABYLON.Vector3 Parses a roll-pitch-yaw rotation string into a Babylon.js Vector3. Parameters: - rpy : string - Space-separated RPY angles in radians (e.g., \"0 0 1.57\") Returns: BABYLON.Vector3 - RPY rotation vector Note: Maintains ROS convention (Roll, Pitch, Yaw) in Vector3 components Example: import { parseRPY } from '@ranchhandrobotics/babylon_ros' ; // Parse rotation from URDF const rpyStr = \"0 0 1.5708\" ; // 90 degrees yaw const rotation = parseRPY ( rpyStr ); console . log ( rotation ); // Vector3(0, 0, 1.5708) // Use in joint joint . rpy = parseRPY ( \"0.1 0.2 0.3\" ); parseColor(color: string): BABYLON.Color4 Parses an RGBA color string into a Babylon.js Color4. Parameters: - color : string - Space-separated RGBA values (0.0 to 1.0, e.g., \"1.0 0.0 0.0 1.0\") Returns: BABYLON.Color4 - Parsed color Throws: Error if string doesn't contain exactly 4 values Example: import { parseColor } from '@ranchhandrobotics/babylon_ros' ; // Parse material color from URDF const colorStr = \"0.8 0.2 0.1 1.0\" ; // Orange const color = parseColor ( colorStr ); console . log ( color ); // Color4(0.8, 0.2, 0.1, 1.0) // Use in material material . color = parseColor ( \"1.0 0.0 0.0 0.8\" ); // Semi-transparent red Transformation Functions applyRotationToTransform(transformNode: BABYLON.TransformNode, vec: BABYLON.Vector3): void Applies roll-pitch-yaw rotation to a transform node using the correct order. Parameters: - transformNode : BABYLON.TransformNode - The node to rotate - vec : BABYLON.Vector3 - RPY rotation values in radians Behavior: - Applies rotations in the correct order: Yaw (Z), then Pitch (Y), then Roll (X) - Handles ROS to Babylon.js coordinate system conversion - Modifies the transform node in place Example: import { applyRotationToTransform } from '@ranchhandrobotics/babylon_ros' ; // Create transform node const transform = new BABYLON . TransformNode ( \"joint_transform\" , scene ); // Apply 90-degree yaw rotation const rpy = new BABYLON . Vector3 ( 0 , 0 , Math . PI / 2 ); applyRotationToTransform ( transform , rpy ); // Transform is now rotated 90 degrees around Z-axis Usage Examples URDF Data Parsing // Typical URDF parsing workflow const urdfOrigin = \"1.0 0.5 0.25\" ; // Position const urdfRPY = \"0 0 1.5708\" ; // 90\u00b0 yaw const urdfColor = \"0.8 0.2 0.1 1.0\" ; // Orange color // Parse into Babylon.js types const position = parseVector ( urdfOrigin ); const rotation = parseRPY ( urdfRPY ); const color = parseColor ( urdfColor ); // Apply to robot components joint . origin = position ; joint . rpy = rotation ; material . color = color ; Complete Joint Setup // Joint configuration from URDF attributes const joint = new Joint (); joint . name = \"shoulder_joint\" ; joint . origin = parseVector ( \"0.1 0 0.2\" ); // 10cm forward, 20cm up joint . rpy = parseRPY ( \"0 0 0\" ); // No rotation joint . axis = parseVector ( \"0 1 0\" ); // Y-axis rotation // Create transform and apply rotation joint . create ( scene , materialMap ); if ( joint . transform ) { applyRotationToTransform ( joint . transform , joint . rpy ); } Material Setup from URDF // Material definition from URDF const material = new Material (); material . name = \"blue_plastic\" ; material . color = parseColor ( \"0.2 0.3 0.8 1.0\" ); // Blue plastic // Alternative: parse from URDF XML attributes const colorAttr = xmlElement . getAttribute ( \"rgba\" ); if ( colorAttr ) { material . color = parseColor ( colorAttr ); } Error Handling Vector Parsing Errors try { const position = parseVector ( \"1.0 0.5\" ); // Missing Z component } catch ( error ) { console . error ( \"Invalid vector format:\" , error . message ); // Use default value const position = new BABYLON . Vector3 ( 0 , 0 , 0 ); } Color Parsing Errors try { const color = parseColor ( \"1.0 0.0 0.0\" ); // Missing alpha } catch ( error ) { console . error ( \"Invalid color format:\" , error . message ); // Use default color const color = new BABYLON . Color4 ( 0.5 , 0.5 , 0.5 , 1.0 ); } Safe Parsing with Defaults function safeParseVector ( vec : string , defaultValue : BABYLON.Vector3 ) : BABYLON . Vector3 { try { return parseVector ( vec ); } catch ( error ) { console . warn ( `Failed to parse vector \" ${ vec } \", using default` ); return defaultValue ; } } // Usage const position = safeParseVector ( urdfOrigin , new BABYLON . Vector3 ( 0 , 0 , 0 ) ); Coordinate System Handling ROS to Babylon.js Conversion The utilities handle coordinate system differences between ROS and Babylon.js: ROS Coordinate System: - X: Forward - Y: Left - Z: Up - Rotations: Roll (X), Pitch (Y), Yaw (Z) Babylon.js Coordinate System: - X: Right - Y: Up - Z: Forward - Rotations: Applied in specific order for proper transformation Rotation Order // applyRotationToTransform applies rotations in this order: // 1. Yaw rotation around Z-axis // 2. Pitch rotation around Y-axis // 3. Roll rotation around X-axis // This is equivalent to: transformNode . addRotation ( 0 , 0 , vec . z ) // Yaw (Z) . addRotation ( 0 , vec . y , 0 ) // Pitch (Y) . addRotation ( vec . x , 0 , 0 ); // Roll (X) Common Patterns URDF XML Parsing // Typical XML attribute parsing function parseJointFromXML ( jointElement : Element ) : Joint { const joint = new Joint (); joint . name = jointElement . getAttribute ( \"name\" ) || \"\" ; // Parse origin const originElement = jointElement . querySelector ( \"origin\" ); if ( originElement ) { const xyzAttr = originElement . getAttribute ( \"xyz\" ); const rpyAttr = originElement . getAttribute ( \"rpy\" ); if ( xyzAttr ) joint . origin = parseVector ( xyzAttr ); if ( rpyAttr ) joint . rpy = parseRPY ( rpyAttr ); } // Parse axis const axisElement = jointElement . querySelector ( \"axis\" ); if ( axisElement ) { const xyzAttr = axisElement . getAttribute ( \"xyz\" ); if ( xyzAttr ) joint . axis = parseVector ( xyzAttr ); } return joint ; } Material XML Parsing function parseMaterialFromXML ( materialElement : Element ) : Material { const material = new Material (); material . name = materialElement . getAttribute ( \"name\" ) || \"\" ; // Parse color const colorElement = materialElement . querySelector ( \"color\" ); if ( colorElement ) { const rgbaAttr = colorElement . getAttribute ( \"rgba\" ); if ( rgbaAttr ) { material . color = parseColor ( rgbaAttr ); } } // Parse texture const textureElement = materialElement . querySelector ( \"texture\" ); if ( textureElement ) { const filenameAttr = textureElement . getAttribute ( \"filename\" ); if ( filenameAttr ) { material . filename = filenameAttr ; } } return material ; } Performance Considerations String Parsing Optimization // Cache parsed values when possible const positionCache = new Map < string , BABYLON . Vector3 > (); function getCachedVector ( vec : string ) : BABYLON . Vector3 { if ( ! positionCache . has ( vec )) { positionCache . set ( vec , parseVector ( vec )); } return positionCache . get ( vec ) ! ; } Batch Transformations // Apply multiple transformations efficiently function setupTransforms ( transforms : Array < { node : BABYLON.TransformNode , rpy : BABYLON.Vector3 } > ) { scene . beginAnimation (); // Batch updates for ( const { node , rpy } of transforms ) { applyRotationToTransform ( node , rpy ); } scene . endAnimation (); } Integration with Robot Loading The utilities are primarily used during robot loading from URDF: // In urdf.ts module export function loadRobot ( urdfDoc : Document , scene : BABYLON.Scene ) : Robot { const robot = new Robot (); // Parse joints const jointElements = urdfDoc . querySelectorAll ( \"joint\" ); for ( const jointEl of jointElements ) { const joint = new Joint (); // Use utilities for parsing const originEl = jointEl . querySelector ( \"origin\" ); if ( originEl ) { joint . origin = parseVector ( originEl . getAttribute ( \"xyz\" ) || \"0 0 0\" ); joint . rpy = parseRPY ( originEl . getAttribute ( \"rpy\" ) || \"0 0 0\" ); } robot . joints . set ( joint . name , joint ); } return robot ; }","title":"Helper Functions"},{"location":"api/utilities.html#utilities-api","text":"Helper functions for parsing and transforming data between different coordinate systems and formats.","title":"Utilities API"},{"location":"api/utilities.html#parsing-functions","text":"","title":"Parsing Functions"},{"location":"api/utilities.html#parsevectorvec-string-babylonvector3","text":"Parses a space-separated string into a Babylon.js Vector3. Parameters: - vec : string - Space-separated coordinates (e.g., \"1.5 0.0 0.3\") Returns: BABYLON.Vector3 - Parsed vector Throws: Error if string doesn't contain exactly 3 values Example: import { parseVector } from '@ranchhandrobotics/babylon_ros' ; // Parse position from URDF const positionStr = \"1.0 0.5 0.25\" ; const position = parseVector ( positionStr ); console . log ( position ); // Vector3(1.0, 0.5, 0.25) // Use in transform joint . origin = parseVector ( \"0 0 0.1\" );","title":"parseVector(vec: string): BABYLON.Vector3"},{"location":"api/utilities.html#parserpyrpy-string-babylonvector3","text":"Parses a roll-pitch-yaw rotation string into a Babylon.js Vector3. Parameters: - rpy : string - Space-separated RPY angles in radians (e.g., \"0 0 1.57\") Returns: BABYLON.Vector3 - RPY rotation vector Note: Maintains ROS convention (Roll, Pitch, Yaw) in Vector3 components Example: import { parseRPY } from '@ranchhandrobotics/babylon_ros' ; // Parse rotation from URDF const rpyStr = \"0 0 1.5708\" ; // 90 degrees yaw const rotation = parseRPY ( rpyStr ); console . log ( rotation ); // Vector3(0, 0, 1.5708) // Use in joint joint . rpy = parseRPY ( \"0.1 0.2 0.3\" );","title":"parseRPY(rpy: string): BABYLON.Vector3"},{"location":"api/utilities.html#parsecolorcolor-string-babyloncolor4","text":"Parses an RGBA color string into a Babylon.js Color4. Parameters: - color : string - Space-separated RGBA values (0.0 to 1.0, e.g., \"1.0 0.0 0.0 1.0\") Returns: BABYLON.Color4 - Parsed color Throws: Error if string doesn't contain exactly 4 values Example: import { parseColor } from '@ranchhandrobotics/babylon_ros' ; // Parse material color from URDF const colorStr = \"0.8 0.2 0.1 1.0\" ; // Orange const color = parseColor ( colorStr ); console . log ( color ); // Color4(0.8, 0.2, 0.1, 1.0) // Use in material material . color = parseColor ( \"1.0 0.0 0.0 0.8\" ); // Semi-transparent red","title":"parseColor(color: string): BABYLON.Color4"},{"location":"api/utilities.html#transformation-functions","text":"","title":"Transformation Functions"},{"location":"api/utilities.html#applyrotationtotransformtransformnode-babylontransformnode-vec-babylonvector3-void","text":"Applies roll-pitch-yaw rotation to a transform node using the correct order. Parameters: - transformNode : BABYLON.TransformNode - The node to rotate - vec : BABYLON.Vector3 - RPY rotation values in radians Behavior: - Applies rotations in the correct order: Yaw (Z), then Pitch (Y), then Roll (X) - Handles ROS to Babylon.js coordinate system conversion - Modifies the transform node in place Example: import { applyRotationToTransform } from '@ranchhandrobotics/babylon_ros' ; // Create transform node const transform = new BABYLON . TransformNode ( \"joint_transform\" , scene ); // Apply 90-degree yaw rotation const rpy = new BABYLON . Vector3 ( 0 , 0 , Math . PI / 2 ); applyRotationToTransform ( transform , rpy ); // Transform is now rotated 90 degrees around Z-axis","title":"applyRotationToTransform(transformNode: BABYLON.TransformNode, vec: BABYLON.Vector3): void"},{"location":"api/utilities.html#usage-examples","text":"","title":"Usage Examples"},{"location":"api/utilities.html#urdf-data-parsing","text":"// Typical URDF parsing workflow const urdfOrigin = \"1.0 0.5 0.25\" ; // Position const urdfRPY = \"0 0 1.5708\" ; // 90\u00b0 yaw const urdfColor = \"0.8 0.2 0.1 1.0\" ; // Orange color // Parse into Babylon.js types const position = parseVector ( urdfOrigin ); const rotation = parseRPY ( urdfRPY ); const color = parseColor ( urdfColor ); // Apply to robot components joint . origin = position ; joint . rpy = rotation ; material . color = color ;","title":"URDF Data Parsing"},{"location":"api/utilities.html#complete-joint-setup","text":"// Joint configuration from URDF attributes const joint = new Joint (); joint . name = \"shoulder_joint\" ; joint . origin = parseVector ( \"0.1 0 0.2\" ); // 10cm forward, 20cm up joint . rpy = parseRPY ( \"0 0 0\" ); // No rotation joint . axis = parseVector ( \"0 1 0\" ); // Y-axis rotation // Create transform and apply rotation joint . create ( scene , materialMap ); if ( joint . transform ) { applyRotationToTransform ( joint . transform , joint . rpy ); }","title":"Complete Joint Setup"},{"location":"api/utilities.html#material-setup-from-urdf","text":"// Material definition from URDF const material = new Material (); material . name = \"blue_plastic\" ; material . color = parseColor ( \"0.2 0.3 0.8 1.0\" ); // Blue plastic // Alternative: parse from URDF XML attributes const colorAttr = xmlElement . getAttribute ( \"rgba\" ); if ( colorAttr ) { material . color = parseColor ( colorAttr ); }","title":"Material Setup from URDF"},{"location":"api/utilities.html#error-handling","text":"","title":"Error Handling"},{"location":"api/utilities.html#vector-parsing-errors","text":"try { const position = parseVector ( \"1.0 0.5\" ); // Missing Z component } catch ( error ) { console . error ( \"Invalid vector format:\" , error . message ); // Use default value const position = new BABYLON . Vector3 ( 0 , 0 , 0 ); }","title":"Vector Parsing Errors"},{"location":"api/utilities.html#color-parsing-errors","text":"try { const color = parseColor ( \"1.0 0.0 0.0\" ); // Missing alpha } catch ( error ) { console . error ( \"Invalid color format:\" , error . message ); // Use default color const color = new BABYLON . Color4 ( 0.5 , 0.5 , 0.5 , 1.0 ); }","title":"Color Parsing Errors"},{"location":"api/utilities.html#safe-parsing-with-defaults","text":"function safeParseVector ( vec : string , defaultValue : BABYLON.Vector3 ) : BABYLON . Vector3 { try { return parseVector ( vec ); } catch ( error ) { console . warn ( `Failed to parse vector \" ${ vec } \", using default` ); return defaultValue ; } } // Usage const position = safeParseVector ( urdfOrigin , new BABYLON . Vector3 ( 0 , 0 , 0 ) );","title":"Safe Parsing with Defaults"},{"location":"api/utilities.html#coordinate-system-handling","text":"","title":"Coordinate System Handling"},{"location":"api/utilities.html#ros-to-babylonjs-conversion","text":"The utilities handle coordinate system differences between ROS and Babylon.js: ROS Coordinate System: - X: Forward - Y: Left - Z: Up - Rotations: Roll (X), Pitch (Y), Yaw (Z) Babylon.js Coordinate System: - X: Right - Y: Up - Z: Forward - Rotations: Applied in specific order for proper transformation","title":"ROS to Babylon.js Conversion"},{"location":"api/utilities.html#rotation-order","text":"// applyRotationToTransform applies rotations in this order: // 1. Yaw rotation around Z-axis // 2. Pitch rotation around Y-axis // 3. Roll rotation around X-axis // This is equivalent to: transformNode . addRotation ( 0 , 0 , vec . z ) // Yaw (Z) . addRotation ( 0 , vec . y , 0 ) // Pitch (Y) . addRotation ( vec . x , 0 , 0 ); // Roll (X)","title":"Rotation Order"},{"location":"api/utilities.html#common-patterns","text":"","title":"Common Patterns"},{"location":"api/utilities.html#urdf-xml-parsing","text":"// Typical XML attribute parsing function parseJointFromXML ( jointElement : Element ) : Joint { const joint = new Joint (); joint . name = jointElement . getAttribute ( \"name\" ) || \"\" ; // Parse origin const originElement = jointElement . querySelector ( \"origin\" ); if ( originElement ) { const xyzAttr = originElement . getAttribute ( \"xyz\" ); const rpyAttr = originElement . getAttribute ( \"rpy\" ); if ( xyzAttr ) joint . origin = parseVector ( xyzAttr ); if ( rpyAttr ) joint . rpy = parseRPY ( rpyAttr ); } // Parse axis const axisElement = jointElement . querySelector ( \"axis\" ); if ( axisElement ) { const xyzAttr = axisElement . getAttribute ( \"xyz\" ); if ( xyzAttr ) joint . axis = parseVector ( xyzAttr ); } return joint ; }","title":"URDF XML Parsing"},{"location":"api/utilities.html#material-xml-parsing","text":"function parseMaterialFromXML ( materialElement : Element ) : Material { const material = new Material (); material . name = materialElement . getAttribute ( \"name\" ) || \"\" ; // Parse color const colorElement = materialElement . querySelector ( \"color\" ); if ( colorElement ) { const rgbaAttr = colorElement . getAttribute ( \"rgba\" ); if ( rgbaAttr ) { material . color = parseColor ( rgbaAttr ); } } // Parse texture const textureElement = materialElement . querySelector ( \"texture\" ); if ( textureElement ) { const filenameAttr = textureElement . getAttribute ( \"filename\" ); if ( filenameAttr ) { material . filename = filenameAttr ; } } return material ; }","title":"Material XML Parsing"},{"location":"api/utilities.html#performance-considerations","text":"","title":"Performance Considerations"},{"location":"api/utilities.html#string-parsing-optimization","text":"// Cache parsed values when possible const positionCache = new Map < string , BABYLON . Vector3 > (); function getCachedVector ( vec : string ) : BABYLON . Vector3 { if ( ! positionCache . has ( vec )) { positionCache . set ( vec , parseVector ( vec )); } return positionCache . get ( vec ) ! ; }","title":"String Parsing Optimization"},{"location":"api/utilities.html#batch-transformations","text":"// Apply multiple transformations efficiently function setupTransforms ( transforms : Array < { node : BABYLON.TransformNode , rpy : BABYLON.Vector3 } > ) { scene . beginAnimation (); // Batch updates for ( const { node , rpy } of transforms ) { applyRotationToTransform ( node , rpy ); } scene . endAnimation (); }","title":"Batch Transformations"},{"location":"api/utilities.html#integration-with-robot-loading","text":"The utilities are primarily used during robot loading from URDF: // In urdf.ts module export function loadRobot ( urdfDoc : Document , scene : BABYLON.Scene ) : Robot { const robot = new Robot (); // Parse joints const jointElements = urdfDoc . querySelectorAll ( \"joint\" ); for ( const jointEl of jointElements ) { const joint = new Joint (); // Use utilities for parsing const originEl = jointEl . querySelector ( \"origin\" ); if ( originEl ) { joint . origin = parseVector ( originEl . getAttribute ( \"xyz\" ) || \"0 0 0\" ); joint . rpy = parseRPY ( originEl . getAttribute ( \"rpy\" ) || \"0 0 0\" ); } robot . joints . set ( joint . name , joint ); } return robot ; }","title":"Integration with Robot Loading"},{"location":"api/visual.html","text":"Visual API The Visual class represents a visual component that can be rendered in 3D space, containing geometry, materials, and transform information. Constructor const visual = new Visual (); Creates a new Visual instance with default values. Properties Public Properties Property Type Description name string Visual component name geometry IGeometry \\| undefined The 3D geometry to render material Material \\| undefined Material properties (color, texture) origin BABYLON.Vector3 Position offset from parent rpy BABYLON.Vector3 Roll, pitch, yaw rotation (radians) transform BABYLON.TransformNode \\| undefined The 3D transform node Methods Lifecycle Methods create(scene: BABYLON.Scene, materialMap: Map<string, Material>): void Creates the visual component in the 3D scene with geometry and materials. Parameters: - scene : BABYLON.Scene - The Babylon.js scene - materialMap : Map - Available materials Behavior: - Creates a TransformNode with position and rotation - Resolves material references from the material map - Creates the geometry with the resolved material - Establishes parent-child transform relationship Example: visual . create ( scene , materialMap ); dispose(): void Cleans up all resources including geometry, materials, and transforms. Behavior: - Disposes geometry resources - Disposes non-reference materials (reference materials are handled by Robot) - Disposes transform node Example: visual . dispose (); State Management setEnabled(enabled: boolean): void Controls the visibility and rendering of the visual component. Parameters: - enabled : boolean - true to show, false to hide Example: visual . setEnabled ( false ); // Hide the visual visual . setEnabled ( true ); // Show the visual isEnabled(): boolean Checks if the visual component is currently enabled/visible. Returns: boolean - true if enabled, false if disabled Example: if ( visual . isEnabled ()) { console . log ( \"Visual is currently visible\" ); } Usage Examples Basic Visual with Box Geometry import { Visual } from '@ranchhandrobotics/babylon_ros' ; import { BoxGeometry } from '@ranchhandrobotics/babylon_ros' ; const visual = new Visual (); visual . name = \"chassis_visual\" ; visual . geometry = new BoxGeometry ( 2 , 1 , 0.5 ); // 2x1x0.5 meter box visual . origin = new BABYLON . Vector3 ( 0 , 0 , 0.25 ); // Raise 25cm visual . rpy = new BABYLON . Vector3 ( 0 , 0 , Math . PI / 4 ); // 45\u00b0 yaw rotation visual . create ( scene , materialMap ); Visual with Mesh Geometry and Material const visual = new Visual (); visual . name = \"robot_body\" ; visual . geometry = new MeshGeometry ( \"robot_chassis.dae\" ); // Use a specific material const redMaterial = new Material (); redMaterial . name = \"red_plastic\" ; redMaterial . color = new BABYLON . Color4 ( 1 , 0 , 0 , 1 ); // Red visual . material = redMaterial ; visual . create ( scene , materialMap ); Visual with Material Reference const visual = new Visual (); visual . name = \"wheel_visual\" ; visual . geometry = new CylinderGeometry ( 0.1 , 0.3 , 0.3 ); // 10cm height, 30cm diameter // Reference an existing material by name const materialRef = new Material (); materialRef . name = \"black_rubber\" ; // Must exist in materialMap visual . material = materialRef ; visual . create ( scene , materialMap ); Geometry Types The Visual class works with any geometry that implements the IGeometry interface: Primitive Geometries // Box geometry visual . geometry = new BoxGeometry ( width , height , depth ); // Sphere geometry visual . geometry = new SphereGeometry ( radius ); // Cylinder geometry visual . geometry = new CylinderGeometry ( height , topRadius , bottomRadius ); Mesh Geometries // Load from file (DAE, STL, etc.) visual . geometry = new MeshGeometry ( \"path/to/model.dae\" ); // The geometry will handle loading and material application Transform and Positioning Origin Position // Position relative to parent transform visual . origin = new BABYLON . Vector3 ( 1 , 0 , 0.5 ); // 1m right, 0.5m up Roll-Pitch-Yaw Rotation // Rotation in radians visual . rpy = new BABYLON . Vector3 ( 0 , // Roll around X-axis Math . PI / 6 , // Pitch around Y-axis (30\u00b0) Math . PI / 4 // Yaw around Z-axis (45\u00b0) ); Transform Hierarchy // Visual transforms are automatically parented // Parent -> Visual Transform -> Geometry Transform if ( visual . transform && visual . geometry ? . transform ) { console . log ( \"Transform hierarchy established\" ); // Move the entire visual (geometry moves with it) visual . transform . position = new BABYLON . Vector3 ( 0 , 1 , 0 ); } Material Handling Direct Material Assignment const material = new Material (); material . color = new BABYLON . Color4 ( 0 , 1 , 0 , 1 ); // Green material . name = \"green_plastic\" ; visual . material = material ; Material Reference // Reference a material that exists in the material map const materialRef = new Material (); materialRef . name = \"existing_material\" ; // Must be in materialMap visual . material = materialRef ; Material Priority Visual material : If specified, takes priority Link material : Falls back to parent link's material Default material : Uses \"default\" from material map Visibility Control Show/Hide Visual // Hide for debugging or performance visual . setEnabled ( false ); // Show when needed visual . setEnabled ( true ); // Check current state if ( ! visual . isEnabled ()) { console . log ( \"Visual is hidden\" ); } Collision vs Visual // Visual components (what you see) const visual = new Visual (); visual . geometry = new MeshGeometry ( \"detailed_model.dae\" ); link . visuals . push ( visual ); // Collision components (physics shapes, usually hidden) const collision = new Visual (); collision . geometry = new BoxGeometry ( 1 , 1 , 1 ); // Simple box collision . setEnabled ( false ); // Hidden by default link . collisions . push ( collision ); Advanced Usage Multiple Visuals per Link const link = new Link (); // Main body visual const bodyVisual = new Visual (); bodyVisual . geometry = new BoxGeometry ( 1 , 0.5 , 0.3 ); bodyVisual . material = bodyMaterial ; // Decoration visual const logoVisual = new Visual (); logoVisual . geometry = new MeshGeometry ( \"company_logo.dae\" ); logoVisual . origin = new BABYLON . Vector3 ( 0.4 , 0 , 0.15 ); // On front face logoVisual . material = logoMaterial ; link . visuals . push ( bodyVisual ); link . visuals . push ( logoVisual ); Dynamic Visual Updates // Change position at runtime if ( visual . transform ) { visual . transform . position = new BABYLON . Vector3 ( 0 , 0 , 1 ); visual . transform . rotation = new BABYLON . Vector3 ( 0 , 0 , Math . PI ); } // Toggle visibility for debugging visual . setEnabled ( ! visual . isEnabled ()); Accessing Mesh Data if ( visual . geometry ? . meshes ) { for ( const mesh of visual . geometry . meshes ) { console . log ( `Mesh: ${ mesh . name } ` ); console . log ( `Vertices: ${ mesh . getTotalVertices () } ` ); console . log ( `Triangles: ${ mesh . getTotalIndices () / 3 } ` ); } } Error Handling The Visual class provides robust error handling: - Handles missing materials with graceful fallbacks - Manages transform hierarchy safely - Properly disposes resources to prevent memory leaks - Logs warnings for invalid geometry or material references Performance Considerations Geometry Complexity : Balance visual quality with rendering performance Material Sharing : Reuse materials to reduce memory usage Visibility Culling : Use setEnabled(false) to hide unnecessary visuals Resource Management : Always dispose visuals when no longer needed Integration with Robot Structure Visuals are typically components of Links: // Part of robot loading process const link = new Link (); link . name = \"base_link\" ; const visual = new Visual (); visual . geometry = new BoxGeometry ( 1 , 1 , 0.2 ); link . visuals . push ( visual ); // When link.create() is called, all visuals are created too link . create ( scene , materialMap );","title":"Visual"},{"location":"api/visual.html#visual-api","text":"The Visual class represents a visual component that can be rendered in 3D space, containing geometry, materials, and transform information.","title":"Visual API"},{"location":"api/visual.html#constructor","text":"const visual = new Visual (); Creates a new Visual instance with default values.","title":"Constructor"},{"location":"api/visual.html#properties","text":"","title":"Properties"},{"location":"api/visual.html#public-properties","text":"Property Type Description name string Visual component name geometry IGeometry \\| undefined The 3D geometry to render material Material \\| undefined Material properties (color, texture) origin BABYLON.Vector3 Position offset from parent rpy BABYLON.Vector3 Roll, pitch, yaw rotation (radians) transform BABYLON.TransformNode \\| undefined The 3D transform node","title":"Public Properties"},{"location":"api/visual.html#methods","text":"","title":"Methods"},{"location":"api/visual.html#lifecycle-methods","text":"","title":"Lifecycle Methods"},{"location":"api/visual.html#createscene-babylonscene-materialmap-mapstring-material-void","text":"Creates the visual component in the 3D scene with geometry and materials. Parameters: - scene : BABYLON.Scene - The Babylon.js scene - materialMap : Map - Available materials Behavior: - Creates a TransformNode with position and rotation - Resolves material references from the material map - Creates the geometry with the resolved material - Establishes parent-child transform relationship Example: visual . create ( scene , materialMap );","title":"create(scene: BABYLON.Scene, materialMap: Map&lt;string, Material&gt;): void"},{"location":"api/visual.html#dispose-void","text":"Cleans up all resources including geometry, materials, and transforms. Behavior: - Disposes geometry resources - Disposes non-reference materials (reference materials are handled by Robot) - Disposes transform node Example: visual . dispose ();","title":"dispose(): void"},{"location":"api/visual.html#state-management","text":"","title":"State Management"},{"location":"api/visual.html#setenabledenabled-boolean-void","text":"Controls the visibility and rendering of the visual component. Parameters: - enabled : boolean - true to show, false to hide Example: visual . setEnabled ( false ); // Hide the visual visual . setEnabled ( true ); // Show the visual","title":"setEnabled(enabled: boolean): void"},{"location":"api/visual.html#isenabled-boolean","text":"Checks if the visual component is currently enabled/visible. Returns: boolean - true if enabled, false if disabled Example: if ( visual . isEnabled ()) { console . log ( \"Visual is currently visible\" ); }","title":"isEnabled(): boolean"},{"location":"api/visual.html#usage-examples","text":"","title":"Usage Examples"},{"location":"api/visual.html#basic-visual-with-box-geometry","text":"import { Visual } from '@ranchhandrobotics/babylon_ros' ; import { BoxGeometry } from '@ranchhandrobotics/babylon_ros' ; const visual = new Visual (); visual . name = \"chassis_visual\" ; visual . geometry = new BoxGeometry ( 2 , 1 , 0.5 ); // 2x1x0.5 meter box visual . origin = new BABYLON . Vector3 ( 0 , 0 , 0.25 ); // Raise 25cm visual . rpy = new BABYLON . Vector3 ( 0 , 0 , Math . PI / 4 ); // 45\u00b0 yaw rotation visual . create ( scene , materialMap );","title":"Basic Visual with Box Geometry"},{"location":"api/visual.html#visual-with-mesh-geometry-and-material","text":"const visual = new Visual (); visual . name = \"robot_body\" ; visual . geometry = new MeshGeometry ( \"robot_chassis.dae\" ); // Use a specific material const redMaterial = new Material (); redMaterial . name = \"red_plastic\" ; redMaterial . color = new BABYLON . Color4 ( 1 , 0 , 0 , 1 ); // Red visual . material = redMaterial ; visual . create ( scene , materialMap );","title":"Visual with Mesh Geometry and Material"},{"location":"api/visual.html#visual-with-material-reference","text":"const visual = new Visual (); visual . name = \"wheel_visual\" ; visual . geometry = new CylinderGeometry ( 0.1 , 0.3 , 0.3 ); // 10cm height, 30cm diameter // Reference an existing material by name const materialRef = new Material (); materialRef . name = \"black_rubber\" ; // Must exist in materialMap visual . material = materialRef ; visual . create ( scene , materialMap );","title":"Visual with Material Reference"},{"location":"api/visual.html#geometry-types","text":"The Visual class works with any geometry that implements the IGeometry interface:","title":"Geometry Types"},{"location":"api/visual.html#primitive-geometries","text":"// Box geometry visual . geometry = new BoxGeometry ( width , height , depth ); // Sphere geometry visual . geometry = new SphereGeometry ( radius ); // Cylinder geometry visual . geometry = new CylinderGeometry ( height , topRadius , bottomRadius );","title":"Primitive Geometries"},{"location":"api/visual.html#mesh-geometries","text":"// Load from file (DAE, STL, etc.) visual . geometry = new MeshGeometry ( \"path/to/model.dae\" ); // The geometry will handle loading and material application","title":"Mesh Geometries"},{"location":"api/visual.html#transform-and-positioning","text":"","title":"Transform and Positioning"},{"location":"api/visual.html#origin-position","text":"// Position relative to parent transform visual . origin = new BABYLON . Vector3 ( 1 , 0 , 0.5 ); // 1m right, 0.5m up","title":"Origin Position"},{"location":"api/visual.html#roll-pitch-yaw-rotation","text":"// Rotation in radians visual . rpy = new BABYLON . Vector3 ( 0 , // Roll around X-axis Math . PI / 6 , // Pitch around Y-axis (30\u00b0) Math . PI / 4 // Yaw around Z-axis (45\u00b0) );","title":"Roll-Pitch-Yaw Rotation"},{"location":"api/visual.html#transform-hierarchy","text":"// Visual transforms are automatically parented // Parent -> Visual Transform -> Geometry Transform if ( visual . transform && visual . geometry ? . transform ) { console . log ( \"Transform hierarchy established\" ); // Move the entire visual (geometry moves with it) visual . transform . position = new BABYLON . Vector3 ( 0 , 1 , 0 ); }","title":"Transform Hierarchy"},{"location":"api/visual.html#material-handling","text":"","title":"Material Handling"},{"location":"api/visual.html#direct-material-assignment","text":"const material = new Material (); material . color = new BABYLON . Color4 ( 0 , 1 , 0 , 1 ); // Green material . name = \"green_plastic\" ; visual . material = material ;","title":"Direct Material Assignment"},{"location":"api/visual.html#material-reference","text":"// Reference a material that exists in the material map const materialRef = new Material (); materialRef . name = \"existing_material\" ; // Must be in materialMap visual . material = materialRef ;","title":"Material Reference"},{"location":"api/visual.html#material-priority","text":"Visual material : If specified, takes priority Link material : Falls back to parent link's material Default material : Uses \"default\" from material map","title":"Material Priority"},{"location":"api/visual.html#visibility-control","text":"","title":"Visibility Control"},{"location":"api/visual.html#showhide-visual","text":"// Hide for debugging or performance visual . setEnabled ( false ); // Show when needed visual . setEnabled ( true ); // Check current state if ( ! visual . isEnabled ()) { console . log ( \"Visual is hidden\" ); }","title":"Show/Hide Visual"},{"location":"api/visual.html#collision-vs-visual","text":"// Visual components (what you see) const visual = new Visual (); visual . geometry = new MeshGeometry ( \"detailed_model.dae\" ); link . visuals . push ( visual ); // Collision components (physics shapes, usually hidden) const collision = new Visual (); collision . geometry = new BoxGeometry ( 1 , 1 , 1 ); // Simple box collision . setEnabled ( false ); // Hidden by default link . collisions . push ( collision );","title":"Collision vs Visual"},{"location":"api/visual.html#advanced-usage","text":"","title":"Advanced Usage"},{"location":"api/visual.html#multiple-visuals-per-link","text":"const link = new Link (); // Main body visual const bodyVisual = new Visual (); bodyVisual . geometry = new BoxGeometry ( 1 , 0.5 , 0.3 ); bodyVisual . material = bodyMaterial ; // Decoration visual const logoVisual = new Visual (); logoVisual . geometry = new MeshGeometry ( \"company_logo.dae\" ); logoVisual . origin = new BABYLON . Vector3 ( 0.4 , 0 , 0.15 ); // On front face logoVisual . material = logoMaterial ; link . visuals . push ( bodyVisual ); link . visuals . push ( logoVisual );","title":"Multiple Visuals per Link"},{"location":"api/visual.html#dynamic-visual-updates","text":"// Change position at runtime if ( visual . transform ) { visual . transform . position = new BABYLON . Vector3 ( 0 , 0 , 1 ); visual . transform . rotation = new BABYLON . Vector3 ( 0 , 0 , Math . PI ); } // Toggle visibility for debugging visual . setEnabled ( ! visual . isEnabled ());","title":"Dynamic Visual Updates"},{"location":"api/visual.html#accessing-mesh-data","text":"if ( visual . geometry ? . meshes ) { for ( const mesh of visual . geometry . meshes ) { console . log ( `Mesh: ${ mesh . name } ` ); console . log ( `Vertices: ${ mesh . getTotalVertices () } ` ); console . log ( `Triangles: ${ mesh . getTotalIndices () / 3 } ` ); } }","title":"Accessing Mesh Data"},{"location":"api/visual.html#error-handling","text":"The Visual class provides robust error handling: - Handles missing materials with graceful fallbacks - Manages transform hierarchy safely - Properly disposes resources to prevent memory leaks - Logs warnings for invalid geometry or material references","title":"Error Handling"},{"location":"api/visual.html#performance-considerations","text":"Geometry Complexity : Balance visual quality with rendering performance Material Sharing : Reuse materials to reduce memory usage Visibility Culling : Use setEnabled(false) to hide unnecessary visuals Resource Management : Always dispose visuals when no longer needed","title":"Performance Considerations"},{"location":"api/visual.html#integration-with-robot-structure","text":"Visuals are typically components of Links: // Part of robot loading process const link = new Link (); link . name = \"base_link\" ; const visual = new Visual (); visual . geometry = new BoxGeometry ( 1 , 1 , 0.2 ); link . visuals . push ( visual ); // When link.create() is called, all visuals are created too link . create ( scene , materialMap );","title":"Integration with Robot Structure"}]}